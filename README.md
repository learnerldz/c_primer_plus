# c_primer_plus
# 一.初识 C 语言 
## 1 .C 语言的起源
- 1972年,贝尔实验室的**丹尼斯·里奇**和**肯·汤普逊**在开发 **UNIX 操作系统**时在**B 语言**的基础上设计了 **C** 语言
## 2. 选择 C 语言的理由
- ### 设计特性
	- 易懂,可靠
- ### 高效性
	- 相对紧凑;运行时间快
	- 微调控制能力**汇编语言**特性（可以根据具体情况**微调程序**获得**最大运行速度**或**最有效**地使用内存）
		- **汇编语言**: 为特殊的中央处理单元设计的⼀系列内部指令, 使用助记符来表示
			- 不同的 CPU 系列使用不同的汇编语言
- ### 可移植性
	- 意味着：**在⼀种系统中编写的 C 程序稍微修改就可以在其他系统运行**
		- **编译器**:把 C 代码转换成计算机**内部指令**的程序
- ### 面向程序员
	- **优点**:许多任务用 C 来处理都非常**简洁** (例如:转换数据的格式）
	- **缺点**: C 语言使用**指针**, 易犯错, 难察觉
## 3.C 语言的应用范围
- C 语言是**嵌入式系统编程**的流行语言
- C 语言从长期被 FORTRAN 独占的**科学编程领域**分得一杯羹
- **UNIX 操作系统**, 大部分是用 C 语言写的
- 其他语言 (如 FORTRAN, Perl, Python、Pascal, LISP, Logo, BASIC)的许多**编译器**和**解释器**都是用 C 语言编写的
## 4. 使用C 语言的7个步骤
- 1. 定义程序的目标; 2. 设计程序; 3. 编写代码; 4. 编译; 5. 运行程序; 6. 测试和调试程序; 7. 维护和修改程序
	- **运行程序**需要**集成开发环境**(IDE)
	- **调试**:查找并修复程序错误的过程
## 5.编程机制
-  ![[Pasted image 20230914170820.png]]
- **源代码文件**:编写程序时, 存储*源代码*(编写的内容)的文本文件
- **目标代码文件**:存储机器语言代码 (由源代码转换)的文件
	- 基本名:点号 (.)前面的部分
	- 扩展名:点号后面的部分
- **启动代码**:程序和操作系统间的接口
- **链接器**的作用:把编写的目标代码(大括号内的代码),系统的标准启动代码（`#include <stdio.h >` 和 `int main()`）和库代码合并成<font color="#ffff00">可执行文件</font>
	- 链接器只提取程序中要用到的**库函数代码**
	- **可执行代码**: 用计算机的**机器语言**表示的代码
- **编译器**:把 C 代码转换成计算机**内部指令**的程序
# 二.C 语言概述
## 1. 代码含义
- ![[Pasted image 20230901014006.png]]
-  `#include<stdio.h>` 告诉编译器把 stdio. h 中的内容包含在当前程序 
	- `#include <stdio.h>` 是一条 C **预处理器指令**
	- stdio.h (**标准输出/输入头文件**)包含编译器使用的函数信息
-  `int main(void)` 函数是 C 程序的基本模块
	- main()是函数名
	- int 表示 main()函数返回一个整数 
	- void 表示 main()不带任何参数
	- 旧式的代码会出现 `main()` 和 `void main()` 
- `/*这是一段的注释*/` 和 `//这是一行的注释` 编译器会忽略
-  `{这里面是函数体}`; `int num` 声明变量类型; `num=1;` 赋值表达语句;
	- 花括号{}还可用于把函数中的多个语句合并为有一个单元或块 (复合语句)
	- **声明**是 C 语言最重要的特性之一; `int` 是 C 语言中的一个**关键字**; `num` 是一个**标识符**
- **命名**
	- 能清楚地表达自身的用途
	- 可以用**小写字母, 大写字母, 数字, 下划线** (`__`) 来命名
	- 首个字符必须是字母或下划线; 不能是数字
	- 不能使用**关键字**和**保留标识符**
- **声明变量**: 未提前声明变量,将无法通过编译
- **调用函数**: 在程序中使用函数
- **预处理**: C 编译器在编译前对源代码做的准备工作
- **头文件**: 在 C 程序顶部的信息集合
-  `return 0;` 在有返回值的函数中一定要有 
## 2. 提高程序的可读性  
- 选择有意义的函数名和写注释  
- 在函数中用空行分隔概念上的多个部分  
- 每条语句各占一行  
## 3. 多个函数     
- **程序状态**:在程序的执行过程中,某给定点上所有变量值的集合  
- **调试器**是一种程序,可逐步运行一个程序,并检查该程序变量的值
## 4. 关键字和保留标识符  
- **关键字** ![[Pasted image 20230903173848.png]]  
- **保留标识符**包括以下划线字符开头的标识符和标准库函数名,如 printf()
# 三. 数据和 C  
## 1.变量与常量数据  
- **常量**: 在程序使用前就设定好,程序运行过程中无变化  
- **变量**: 在程序运行期间可能会改变或被赋值  
## 2. 数据: 数据类型关键字  
- int long short unsigned char float double signed void `_Bool` `_Complex` `_Imaginary ` 
- **关键字含义**
	- signed 用于提供基本整数类型的变式,例: unsigned short int 和 long long int  
	- char 关键字用于指定字母和其他字符（如:# $ % `*`）和较小的整数
	- float、double 和 long double 表示带小数点的数 
	- `_` Bool 类型表示布尔值 (true 或 false), `_  Complex ` 和  `_ Imaginary ` 分别表示复数和虚数
- **位,字节,字**
	- **位** (bit)存储 0 或 1
	- **字节**一个字节为 8 位;有 256 种可能
	- **字** 设计计算机时给定的自然存储单位,大多数为 32 位和 64 位
- **整数**: 没有小数部分的数
- **浮点数**: 实数 (带小数部分)
## 3. C 语言的基本数据类型  
- ### int 类型 (有符号整型)  
	- 取值范围 16 位为-32768~32767 (-2<sup>15</sup>~2<sup>15</sup>-1)  
	- **初始化变量**: 为变量赋一个初始值  
	- %d (十进制);%o (八进制); %x (十六进制) 打印变量  
		- 显示各进制数的前缀0、0x 和0X 需要加# `% #o`  例如: 3F 使用 `%X`; OX3A 使用 ` % #X ` (# 数字前加上 OX)
- ### 其他整数类型  
	- **short int** `%hd` 常用于较小数值的场景节省空间 (有符号) 16 位  
	- **long int** `%ld` 较大的数比较占用空间 (有符号) 16 位或者 32 位(*一般为 32 位*)  
	- **long long** `%lld;%llu;%#llo;%#llx` 占据64 位 (有符号)  
	- **unsigned int** `%u` 为正整数 (无符号) 16 位的范围 (0~2<sup>16</sup>-1)  
	- *signed 是强调使用有符号类型的意图可以省略*
	- long 常量  
		- 八进制和十六进制常量被视为 int 类型  
		- 如果数值过大依次使用unsigned int、long、unsigned long、long long 和 unsigned long long 类型  
		- 把⼀个较小的常量作为 long 类型对待: 在值的末尾加上 l 或者 L 后缀 (也可用于八进制和十六进制)
			- 同理: long long 为 LL 后缀; unsigned long long 为 ULL  
	- **整数溢出**(溢出行为是未定义行为)
- ### 使用字符: char 类型
	- 实际上存储的是整数.例如:在 **ASCII 码**中,整数65 代表大写字母 A  
		- **ASCII 码**:0~127 由七位二进制数表示
			- 48~57 表示'0'~'9'
			- 65~90 表示'A'~'Z'
			- 97~122 表示'a'~'z'
		- **char 类型**为 8 位存储单元  
	- **字符常量初始化**  
		- 例如: `char grade = 'A' ` 必须要加单引号  
		- 在 C 语言中,用单引号括起来的单个字符被称为**字符常量**![[code6.png]]  
		- 对于'ABCD'把四个独立的 8 位 ASCII 码存储在一个 32 位中 *但把'ABCD'赋值给 char 则 char 为'D'   
	- **非打印字符**  
		- 注意:\\Ooo 前面的 O 可以省略 也表示八进制 ![[Pasted image 20230905180749.png]]  
		- **行为字符表示方法**
			- 1. 使用 ASCII 码 `char beep = 7`
			- 2. 使用特殊的符号序列 (见上图: **转义序列**) `char ner = '\n' `
				- 报警字符不得改变**活跃位置**(显示设备中下一个字符将出现的位置)![[Pasted image 20230905182923.png]]
			- 3. 用十六进制形式表示字符常量 ('\\xF')
				-  反斜杠后面跟⼀个 x 或 X,再加上1~3位十六进制数字
	- **打印字符**(%c)
	- **有符号还是无符号**
		- 可以在 char 前加上 signed (有符号) 或 unsigned (无符号)
		- 无符号的 char 类型在处理小整数时很好用
- ### -Bool 类型 
	- 表示**布尔值** (逻辑 true 1 和 false 0)
	- 也是一种整数类型,原则上占一位
- ### 可移植类型: stdint. h 和 inttypes. h 
	- stdint.h (*可以不用 stdint.h 使用 int32_t 移植的话需要使用 stdint.h*)
		- **精确宽度整数类型**
			- int32_t  (这些是前缀)
			- 整数类型的宽度正好是32 位
			- 计算机底层可能不支持
		- **最小宽度类型**
			- int_least8_t
			- 可容纳8位有符号整数值的类型中宽度最小的类型
		- **最快最小宽度类型**
			- int_fast8_t
			- 系统中对8位有符号值而言运算最快的整数类型
			- 可使计算达到最快的类型
		- 其他
			- 最大的有符号整数类型**intmax_t**
			- 最大的无符号整数类型**uintmax_t**
	- inttypes. h
		- PRId32 字符串宏来打印 int32_t 类型的值 
	- ![[Pasted image 20230906164743.png]]  
		- 该程序最后⼀个 printf()中，参数 PRId32被定义在 inttypes.h 中的"d"替换等价于: ![[Pasted image 20230906164854.png]] 多个连续的字符串组合成一个字符串![[Pasted image 20230906165045.png]]  
- ### float、double 和 long double 
	- 计数法 ([[计算机科学导论#^296905|存储方式]])
		- 科学计数法: 1.0 x 10<sup>9</sup>
		- 指数计数法: 1.0e9 或 1.0E9 (不可以加空格)
	- float: 32 位表示 8 位指数 1 位符号 23 个尾数 (有效数)![[Pasted image 20230824025433.png]]  
	- double: 64 位表示 11 位指数 1 个符号 52 个尾数![[Pasted image 20230824025454.png]]  
	- **浮点数常量**
		- 正号可以省略; 小数点和指数不可同时省略 
		- 在程序中可以 1.0 或者 1E2 (无空格) 表示
		- *输入的浮点数默认为 double* 可以加后缀 f 来表示 float l 表示 long double
			- **添加 f 后缀的好处**: 2.0 x 2.0 运算时为两个 double 类型 结果需要截断 (影响速度) 而两个 f 则不需要
		- **十六进制表示**
			- 加上 ox 前缀; 用 p 和 P 代替 e 和 E .例如: oxa.1fp10 表示十六进制的 a.1f x 2<sup>10</sup>
			- p 是指 2 的幂; e 是 10 的幂
	- **打印浮点值**
		- **%f** 打印**十进制**的 float 类型
		- **%e** 打印**指数**计数法的浮点数
			- printf 打印出的形式: `1.234E+09`
		- **%a** 打印**十六进制的指数**计数法的浮点数
		- 在前面加上 l 可打印对应的 long 类型
			- **%lf** 打印 **long double**
	- **浮点值的上溢和下溢**
		- 上溢 (现在会输出*无穷大*)
		- 下溢 (损失精度 可能出现较大误差 下溢后输出 nan 或 NAN)
		- **舍入错误**: 精度不够导致某几位上的数据丢失
		- [[计算机科学导论#^c95a9e|上溢和下溢的详细介绍]]
- ### 复数和虚数类型 
	- *3 种复数类型* 
		- float_Complex (包含**两个** float 的值 分别表示**实部和虚部**)
		- double_Complex
		- long double_Complex
	- *3 种虚数类型*
		- float_Imaginary
		- double_Imaginary
		- long double_Imaginary
	- complex. h 头文件中可以用 complex 代替_Complex; imaginary 代替_Imaginary 用 I 代替-1的平方根  
		- 例如: float complex a = x x x ;
		- 为何 C 标准不直接用 complex 作为关键字来代替_Complex?
		   *因为在此之前有许多人用到了 complex因此它不能变成关键词*
- ### 其他类型 
	- 字符串  数组  **指针**  结构  联合
	-  **声明变量**
		- 可以同时声明多个变量: ![[Pasted image 20230907024222.png]]
		- 可以在声明变量的同时初始化变量: ![[Pasted image 20230907024258.png]]  
## 4. 使用数据类型  
- ![[Pasted image 20230907150239.png]]  
	- C 编译器把浮点数转换成整数时,会**丢弃小数部分不会四舍五入**
		- 例如: int a=3.1 则 a=3 (在赋值时会出现这种情况)
		- 但是在 **printf** 和 **scanf** 中 ("%d", 3.1) 则会出错,而不是 3
	- C 只保证了 float 类型前六位的精度
	- 允许编写**混合数据类型**的表达式 (例如: `int a=1;printf("%lf",a*1.1);` 这时输出 1.1 而不是 1; a x 1.1 为 double 类型)
- 大多数情况下有以下约定
	- 用 i_前缀表示 int 类型 ; 例如: i_smart  
	- 用 us_前缀表示 unsigned short 类型 ; 例如:us_versmart
## 5. 参数和陷阱 
- printf ()括号中的**一个字符串**为一个参数
	- 但是参数是可变的例如: printf ("%d %d", a ,b); 这其中就有 3 个参数
	- **参数**之间用**逗号**隔开
- scanf ("%d"&a); 为两个参数
- *注意参数的数量类型相匹配*
## 6. 转义序列 
- 可以定义 char 字符类型使用
	- char a='\\n';
	- printf ("%c" a);
- 也可以直接在 printf 中当作字符使用 (printf 双引号内的是**字符串**)
	- printf ("\\n")
- *一些转义字符可能与现代的图形接口兼容*
- **刷新输出**
	- 最初 printf ()语句把输出发送到**缓冲区**(中间存储区域), 然后发送到屏幕
	- **刷新缓冲区**: 缓冲区的数据发送到屏幕或文件
	- C 标准规定: 当*缓冲区满*, *遇到换行字符*或*需要输入时*刷新缓冲区 (另一种刷新缓冲区的方法是**fflush()函数**)
# 四. 字符串和格式化输入/输出
## 1. 字符串简介
- **字符串**: 一个或多个字符的序列
	- printf ("这里面是字符串");
	- char a[ ] =我也是字符串; printf ("%s", a);
	- 也可以声明多个 char 字符, 再放入数组中 (**在末尾加一个\\0**, 不加也可以)
- ### char 类型数组和 null 字符
	- 字符串存储在连续的 char 类型的数组中
		- *空格也是一个字符, 字符串末尾还有\\0*
	- **空字符**\\0不是数字 0, 但是在 ASCII 编码中为 0 (**非打印字符**)
		- 数组的容量是**字符数+1**
		- \\0 是 char a=0; 而不是 char a='0'
- ### 使用字符串
	- printf ()和 scanf ()双引号内的文本是一个字符串,*编译器会在末尾加上空字符*
	- scanf ()只读取 Angela Plains 中的 Angela, 在遇到**第一个空白**(**空格, 制表符\\t,\\v 或换行符\\n**)时不再输入
		- scanf 只会读取一个单词而不是一句话
		- 其他输入函数: **fgets()**, 用于读取一般字符串 (包括空白)
	- 字符和字符串
		- 'x'是一个字符
		- "x"是一个字符串, 包含'x','\\0'
- ### strlen ()函数
	- sizeof 和 strlen
		- sizeof 占据的字节
		- <font color="#ffff00">strlen</font> 字符长度 (不包括'\\0')
	- ![[Pasted image 20230910230350.png]]
		- `char name[40]` sizeof 得到 40
		- strlen 是 11 (只有前 11 个用于存储)
## 2. 常数和 C 预处理器指令 
- 定义常量
	- 使用变量的缺点: 程序可能无意间改变其数值 
	- C 预处理器 `#define TAXRATE 0.015` 
		- **编译时替换**:编译时,程序中的 TAXRATE 都会替换成 0.015
		- **明示常量** `#define TAXRATE 0.015`
			- 在程序中不能⽤圆括号代替花括号
		- *常量一般使用大写; 无"="和";"* 
- ### const 限定符
	- 只读不写, 定义后不能改变
- ### 明示常量
	- limits. h 整数类型大小限制及实现他的明示变量
		- 例如: CHAR_BIT char 类型的位数
		- 表示效果
			- MAX 最大值 
			- MIN 最小值
			- `BIT` **位数**
		- 类型
			- `CHAR` char 类型
			- `SCHAR` signed char 类型
			- `UCHAR` unsigned char 类型
			- `INT` int 类型 
			- `UINT` unsigned int 类型
			- `LLONG` long long 类型
	- float. h
		- FLT_DIG 和 DBL_DIG，分别表示 float 类型和 double 类型的有效数字(**尾数**)位数
		- DBL 和 LDBL,分别表示 double 和 long double 类型
		- **明示变量**
			- `FLT_MANT_DIG` float 类型的尾数位数
			- `FLT_DIG` float 类型的最少有效数字位数（十进制）
			- `FLT_MIN(MAX)_10_EXP` 带全部有效数字的 float 类型的最小 (最大)负指数（以10为底）
			- `FLT_MIN (MAX)` **保留全部精度**的 float 类型最小 (最大)正数
			- `FLT_EPSILON` 1.00和比1.00⼤的最小 float 类型值之间的差值*1.192093e-07*
	- 例: printf("%d %e",FLT_DIG,FLT_EPSILON)
## 3. printf ()和 scanf ()
- 输出/输入函数，或简称为 I/O 函数
- 工作原理基本相同:**都使用格式字符串和参数列表**
- 不同:
	- printf()函数使⽤变量、常量和表达式
	- scanf()函数使⽤**指向变量的指针**
- ### printf ()函数
	- 转换说明汇总 ![[Pasted image 20230914165618.png]]
- ### 使用 printf ()
	- 格式:
		- printf( 格式字符串, 待打印项1, 待打印项2,...);
		- **格式字符串**包括**实际打印的字符**和**转换说明**
		- 可以这样![[Pasted image 20230912093423.png]]
	- 打印%要使用两个%
- ### printf ()的转换说明修饰符
	- *在%和转换字符之间插入修饰符可修饰基本的转换说明*![[Pasted image 20230911222143.png]]![[Pasted image 20230911181600.png]] ![[Pasted image 20230911181613.png]]
	- stddef. h 头文件把**size_t** 定义成系统使⽤ sizeof 返回的类型 (称为**底层类型**)
	- **ptrdiff_t** 类型和 **t** 修饰符来表示**系统使⽤的两个地址差值**的底层有符号整数类型![[Pasted image 20230911222011.png]]
- ### 转换说明的意义
	- **转换说明**
		- 把以二进制格式**存储在计算机中的值**转换成**⼀系列字符**(字符串)以便于显示
		- 例如:%x 转换说明把(01001100)转换成十六进制记数法4c
		- 转换说明是**翻译说明**，%d 的意思是把给定的字符<font color="#ffff00">翻译</font>成十进制整数文本并打印出来
	- **转换不匹配**
		- 转换说明的匹配
			- 打印 int 类型可使用%d,%x,%o
			- 打印 double 类型可使用%f,%e,%g
		- 系统使⽤二进制补码来表示有符号整数
		- 还可能出现[[计算机科学导论#^917111|截断]] 
			- 例如: 用一字节的 char 类型的转换说明%c 打印 2 字节的 int 类型, 只打印后一字节
		- 使用%e 打印 long int 变量错误原因
			- %e 让 printf()函数认为待打印的值是 double 类型 (double 8字节)当 printf()查看4字节的值时,还会查看相邻4字节;然后将8字节单元中的位组合解释成浮点数
	- *float 类型的值作为 printf() 参数时会被转换成 double 类型*
	- **参数传递**
		- 程序把传入的值放入被称为**栈**的内存区域
		- 会依次按照转换说明所需取的字节数读取
			- 例如:printf("%ld %ld", n1, n2)(long 类型 4 个字节, double 类型 8 个字节)
			- n1=3.0; 则第一个%ld 取 n1 的前 4 个字节; 第二个%ld 不是取得 n2 而是 n1 的后四个字节
		![[Pasted image 20230912092304.png]]
	- **printf ()的返回值**
		- printf()的返回值是**待显示**字符的个数
		- ⽤rv = printf(...);的形式把 printf()的返回值赋给 rv(rv 的值是 printf 输出的字符串中的**字符数**)
	- **打印较长的字符串**
		- 在字符串中,可使⽤\\n 换⾏,不可用 Enter 换⾏
		- 字符串断行方法 ![[Pasted image 20230912093533.png]]
		- *⽤反斜杠（\\）和 Enter 键组合来断⾏;在下⼀⾏开始 (不能缩进)继续输出*
- ### 使用 scanf ()
	- 简单规则
		- scanf()读取基本变量类型的值,在变量名前加&
		-  scanf()把字符串读入字符数组中,不⽤&
	- 在每个**输入项**之间输入至少⼀个换⾏符、空格或制表符 (可以输入多个, 都不会读取)*但是除了%c 读取字符会读取每一个空格*
		- 例如:scanf("%d%d", &n, &m)与 scanf("%d %d", &n, &m) 的⾏为相同
	- <font color="#ffff00">转换说明的不同</font>
		- printf ()对于 float 和 double 都使用%f (%e,%g)
		- scanf ()对于 float 使用%f (%e,%g); 而对 double 使用 l 修饰
	- **转换说明的修饰符**
		- 必须按照 `*`,数字, hh, ll, (h,l,L), j, z, t 的顺序 ![[Pasted image 20230912100247.png]]
	- **从 scanf ()角度看输出**
		- 使⽤带多个转换说明的 scanf(),在第1个出错处停止"**读取输入**"
		- *%s 会读取所有非空格字符, 遇到空白就停止*(使用最大字符宽度也不能让只有⼀个%s 的 scanf()读取多个单词; 但 printf 可以输出整句话, 包括空格)
	- **格式字符串中的普通字符**
		- 可以把普通字符放在格式字符串中; 例如 `scanf("%d,%d",&a,%b)` 则要输入 `2,3`
		- *空格在%c前,scanf ()会跳过空格,从第1个非空白字符开始读取*
			- scanf ("%c", &ch)从输⼊中的第1个字符 (可以是空白字符)开始读取
			- scanf (" %c", &ch)从第1个非空白字符开始读取
	- **scanf ()的返回值**:scanf()函数返回成功读取的项数 (**类似 printf 返回值**)
		- 例如: `status = scanf("%ld", &num);` scanf()成功读取⼀个整数,就把该数存⼊num 并返回1，然后将返回值赋给 status
		- 1.**返回-1**:当 scanf()检测到“文件结尾”时,会返回 EOF
			- （EOF 是 stdio.h 中定义的特殊值，通常⽤ `#define` 指令把 EOF 定义为-1)
		- 2.**返回 0**:没有读取任何项,且需要读取⼀个数字却输⼊⼀个非数值字符串
- ### printf ()和 scanf ()的 `*` 修饰符
	- printf ()中的 `*`
		- 不预先指定字段宽度,通过程序来指定,那么可以⽤ `*` 修饰符代替字段宽度
		- 例如: printf ("%2.3f", c); 可以写成 `printf ("%*.*f",a=2,b=3,c);`
	- scanf ()中的 `*`
		- 把 `*` 放在%和转换字符之间时,会使 scanf()跳过相应的输入项
		- 例如: `scanf("%*d %*d %d", &n);` 前两个被跳过 
- ### printf ()的用法提示
	- %9d 类似的用于数据的对齐
	- %.2f 可以更美观
	- **本地化设置**
		- 例如: 在荷兰语言环境下"." 是逗号","
		- C 标准有两个本地化设置: "C"和" "(空字符串)
# 五. 运算符, 表达式和语句
## 1. 基本运算符
- **pow() 函数**⽤于**指数**运算. 例如:pow(3.5, 2.2)返回3.5的2.2次幂
- =,+,-, `*`,/  都是二元运算符
- ### 赋值运算符:=
	- 左侧是变量名, 赋值从左往右
	- a=a+1:找出变量 a 的值,把该值加1,然后把新值赋值变量 a
	- **标识对象的方法**
		- 1. 使用变量名
		- 2. 指定数组的元素, 结构的成员
		- 3. 使用指针表达式
	- 术语:
		- **数据对象**: 
			- 概念:用于存储**值**的**数据存储区域**
			- 对象:实际的数据存储
			- 左值:用来表示或定位存储位置的标签
		- **左值**
			- 概念:标识**特定数据对象**的名称或表达式
			- 一些左值不能放在赋值的左侧: <font color="#ffff00">const 变量</font>
			- 赋值运算符的左侧是**可修改的左值**(又叫**对象定位值**)
		- **右值**(**表达式的值**)
			- 概念:能赋值给可修改左值的量,本身不是左值
			- 可以是常量, 变量或其他可求值的量
		- **运算对象**(项)
			- 运算对象是运算符操作的对象
			- 例如:赋值运算符左侧的"项"
	- *可进行多次连续赋值, 顺序**从右到左***
- ### 符号运算符
	- +-作加法减法运算符:**二元运算符**
	- +-作符号运算符时:**一元运算符**
- ### 除法运算符
	- **截断**:整数除法结果的丢弃小数部分 (不是四舍五入)
	- **趋零截断**: 当结果是负数时, 直接丢弃小数部分
- ### 运算符优先级
	- **表达式树**![[Pasted image 20230913204648.png]]
	- 优先级 (*!>算术>关系>&&>||>赋值*)
		- **初级运算符**( )、[ ]、->、.  高于**单目运算符**高于**算数运算符**(先乘除后加减)高于**关系运算符**高于**逻辑运算符**(不包括!) 高于**条件运算符**高于**赋值运算符**高于**逗号运算符**
		- 赋值,条件,单目运算符的平级间顺序**从右至左**, 其他都是**从左到右**![[Pasted image 20230913223039.png]]![[Pasted image 20230913223100.png]]![[Pasted image 20230913223121.png]]![[Pasted image 20230913223143.png]]
## 2. 其他运算符
- ### sizeof 运算符和 size_t 类型
	- sizeof (%zd)运算符以**字节**为单位返回运算对象的⼤小
		- 运算对象是类型,必须⽤圆括号括起来 (sizeof (int))
		- **sizeof** 返回**size_t** 类型的值
	- **typedef 机制**:允许程序员为现有类型创建别名
		- 例如: typedef double real;real 是 double 的别名
- ### 求模运算符:%
	- 整数运算, 取余. 例如:13%5 (读作“13 求模5”)得 3
	- *不同符号的数求模, 以第一个数的符号为准*
- ### 递增递减运算符:++  --
	- **++a ()先加 1 再取值**
	- **a++ ()先取值再加 1**
	- 一个良好的习惯
		- 如果不确定时, 可以分开使用
		- `b = ++i; // 如果使用i++，会得到不同的结果`
		- `++i; // 第1⾏ b = i; // 如果第1行使用i++,并不会影响b的值`
	- 递减运算符与递增运算符类似
- ### 注意事项
	- 不要一次用太多的递增递减运算符 
	- *⼀个变量出现在⼀个函数的多个参数中,不要对该变量使⽤递增或递减运算符*
		- 例如: `ans = num/2 + 5*(1 + num++);` 可能先计算 num/2, 也可能先计算 num++(这时会改变 num 的值, 使 num/2 的值改变)
	- ⼀个变量多次出现在⼀个表达式中，不要对该变量使⽤递增或递减运算符
		- 例如: n = 3; y = n++ + n++;
		- 原因: **副作用在序列点前结算**, 但未说明是运算后递增还是递增后运算
## 3. 表达式和语句 
- ### 表达式
	- 组成: **运算符**和**运算对象**(运算符操作的对象)
	- 表达式的值: 与赋值表达式**左侧**值相同
- ### 语句
	- `a=4` 是表达式; `a=4;` 是语句
	- **表达式语句**:以分号结尾的表达式
		- 声明不是表达式语句 (因为去掉分号不是表达式) 例如: `int a; `
	- **简单语句**
		- 最简单的语句是空语句 `;    //空语句`
		- (部分)语句可以**改变值**或**调⽤函数**; 那它是条完整的**指令**
			- 不是所有的指令都是语句;不是所有的语句都可以改变值或调⽤函数 (空语句)
			- 例如: x = 6 + ( y = 5 );y = 5是⼀条完整的指令,但它只是语句的⼀部分
	- **复合语句**(块)
		- ⽤{花括号}括起来的⼀条或多条简单语句
		- 应用: while, for循环, if 条件语句
	- **函数表达式语句**会引起**函数调⽤**
		- while 语句是⼀种**迭代**语句或**结构化**语句
- ### 副作用和序列点
	- **副作用**
		- 定义:对**数据对象**或文件的**修改** `states = 50;`
		- 解释: `states = 2+3;`
			- <font color="#ffff00">主作用</font>: 对表达式求值
			- 副作用:把变量 states 的值改为5
		- 应用:
			- 递增递减运算符就是使用其副作用
			- printf ()显示的信息也是副作用
	- **序列点**
		- 定义:程序执⾏的点 (**分号标记序列点**)
		- 作用:所有副作⽤都在进入下⼀步之前 (**在分号前**)发⽣
		- **完整表达式**
			- 定义: 完整表达式**不**是另⼀个更⼤表达式的**子表达式**
			- 联系: 完整表达式的结束是⼀个序列点
## 4. 类型转换
- **升级和降级**
	- **升级**:类型转换从较小的类型转换为较大类型
	- **降级**: 类型转换从较大的类型转换为较小类型
- 类型的**级别**: long double、double、float、 unsigned long long、long long、unsigned long、long、 unsigned int、int
	- 当 long 和 int 的⼤小相同时,unsigned int 比 long 的级别⾼
- **转换**(重要)
	- 1.类型转换出现在表达式时,char 和 short 都会被⾃动转换成 int
	- 2.在赋值表达式语句中,计算的最终结果会被转换成被赋值变量的类型
	- 3.当作为函数参数传递时，*char 和 short 被转换成 int，float 被转换成 double*
	- 4.涉及两种类型的运算,两个值会被分别转换成两种类型的更⾼级别
- 待赋值的值与目标类型不匹配
	- a=b; a 的类型为**目标类型**; a 是**被赋值变量**; b 是**待赋值的值**![[Pasted image 20230914123415.png]]
- **强制类型转换运算符**
	- **组成**:圆括号和它括起来的类型名 ` (int)`
	- 在某个量前面放置⽤(圆括号)括起来的类型名,该类型名就是希望转换成的目标类型
		- 例如: `mice = (int)1.6 + (int)1.7; ` mice=2
		- `mice = 1.6 + 1.7; ` mice=3 (先计算后截断)
	- 在函数调用时也可使用 `pound ((int)f);`
	- 使⽤**强制类型转换运算符**进⾏**显式转换**, 更直观
# 六. C 控制语句: 循环
- **伪代码**:⽤简单的句子表示程序思路的⽅法
# 1. while 语句
- **形式**: while (测试条件) {复合语句};
- 每次循环都被称为⼀次**迭代**
- 入口条件 (圆括号内)
- ### 终止 while 循环
	- 测试表达式的值有变化,表达式最终要为假
	- break 和 if 语句
- ### while 循环的形式
	- while (条件){复合语句};
	- 几种**易错**情况
		- while (条件); {复合语句};--循环体内为空语句
		- while (条件) 复合语句;--只会生效一条
	- 循环体使用空语句的情况
		- `while (scanf("%d", &num) == 1);` 跳过整数输⼊
		- 这个分号要独占⼀⾏, 提高代码可读性
## 2. 用关系运算符和表达式比较大小
- **关系运算符** "> < >= <= == !="
	- 不能用关系**运算符**比较字符**串**
	- 关系**表达式**比较字符时, 使用机器字符码 (ASCII)
	- **比较浮点数**时少使用"="
		- 原因:浮点数的舍入误差
- ### 真假
	- `while (goats)` 等价 `while (goats != 0)`
	- 关系表达式: 真>>求值为 1; 假>>求值为 0
	- **真** : 非 0 值 ;  **假**: 0
- ⼀个**无限失败**的循环 ( == 换成 = )
	- 当 scanf()把 q 作为整数读取时失败后,把 q 留下,下次循环时,scanf()从上次读取失败的地⽅（q）开始读取，还会失败
- ### _Bool 类型
	- **布尔变量** 
		- 定义:表示真假的变量
		- 只能存储1 (真)或0 (假)
		- *非 0 数值都会被设置为 1*
	- 使用示例: `bool = (scanf("%ld", &a) == 1); `
		- scanf 的返回值与 1 比较, 如果返回值 >=1 就为真, 则 bool=1
	- **stdbool.h 头文件** 
		- _ Bool 的别名 bool
		- true 和 false 定义为1和0的符号常量
		- 可以与 C++兼容:C++把 bool、true 和 false 定义为关键字
## 3. 不确定循环和计数循环
- **不确定循环**:测试表达式为假前,不知道要执⾏多少次循环
- **计数循环**:执⾏循环前知道要重复执⾏多少次
	- 步骤: 
		- 1.必须初始化计数器
		- 2.计数器与有限的值作比较
		- 3.每次循环时递增计数器
## 4. for 循环和 do while 循环
- ### for 循环 
- **形式** 
	- for (初始化; 判断条件; 改变量){复合语句}; 
	- 可以**省略**⼀个或多个表达式,但不能省略**分号**
		- 要保证不是**无限循环**
		- 表达式 2 省略后为**真** (1)
- **步骤**
	- ![[Pasted image 20230915154841.png]]
- 注意事项
	- **表达式 1** 在整个循环中只执行一次; 可以是其他表达式
		- 例如: `for (printf("abc\n"); num != 6;)`
	- **表达式 1,2** 中可以使用 char 字符, 也可以使用不同变量
		- 例如: `for (x = 1; y <= 75; y = (x++ * 5) + 50)`
	- **表达式 3** 中可以使用 a=a+10; a=a* 1.1...
- ### 逗号运算符和其他运算符
	- **其他运算符** += -= `*=` /= %=
		- a+=1; 等效于 a=a+1;
	- **逗号运算符**
		- 在表达式中使用逗号隔开, 可初始化多个变量
			- 例如: `for (a=1,b=2;a<=16;a++,b+=2)`
		- **逗号运算符**把两个表达式连接成⼀个表达式,并保证最左边的表达式最先求值
		- 逗号是**序列点**,左侧项的副作⽤在执⾏右侧项前发⽣
		- *整个式的值逗号表达是右侧项的值*
			- 例如:(b,c)== c
	- **注意**a=b,c; 和 a=(b,c);不同
		- a=b,c 等效于 a=b; c; 把 b 的值赋给 a, `c;` 什么也不做
		- a=(b,c); 把 c 的值赋给了 a
	- **逗号分隔符**
		- 下列语句中逗号为分隔符,不是逗号运算符
		- int a, b; printf ("%d %d\\n", a, b);
- ###  出口条件循环: do while 
	- **入口条件循环**(while 和 for)
		- 在循环的每次迭代前检查测试条件
		- **可能不执⾏**循环体中的内容
	- **出口条件循环**(do while)
		- 在循环的每次迭代后检查测试条件
		- 至少执⾏循环体中的内容**⼀次**
	- **形式**: do {复合语句} while (测试条件);
## 5. 嵌套循环
- **嵌套循环**:在⼀个循环内包含另⼀个循环, 常用于按行按列显示数据
- **嵌套变式**:内层循环开始打印的字符取决于外层循环的迭代次数 ![[Pasted image 20230915193138.png]]
## 6. 数组简介
- **数组**是按顺序存储的⼀系列类型相同的值
- 通过**下标**访问数组中单独的**项**或**元素**
	- 例如: `a[0] = 3;scanf("%f", &a[4]);`
- 数组的类型可以是任意数据类型
	- **形式**: int a[22];
![[Pasted image 20230915201050.png]]
- ### 在 for 循环中使用数组
	- 使用递增量 (i++) 将值存到数组的每个元素中 `for( i=0; i<10; i++ ) { scanf( "%d", &a[ i ] ) }`
- **模块化**:
	- 原则:把程序划分为⼀些独⽴的单元，每个单元执⾏⼀个任务,
	- 作用:可以提⾼程序的可读性
## 7. 计算幂的程序
- 计算幂的函数 ![[Pasted image 20230915204605.png]]
- 返回值也可以是表达式的值
	- 例如: return 2+a;
- ### 使用带返回值的函数
	- 声明函数、调⽤函数、定义函数、使⽤关键字 return，是定义和使⽤带返回值函数的**基本要素**
	- 为什么在定义中说明了 power()的返回类型为 double,还要单独声明这个函数?
		- 编译器在程序中首次遇到 power()时,需要知道 power()的返回类型
	- **前置声明**预先说明函数的返回类型
	- power()函数的定义在 main()的文件上面,就可以省略前置声明
# 七. C 控制语句: 分支和跳转
- if 语句被称为分支语句或选择语句
- if 语句由复合语句构成, 但整个 if 语句为⼀条语句
## 1. if else 语句
- **if 语句**
	- if 语句被称为分支语句或选择语句
	- if 语句由复合语句构成, 但整个 if 语句为⼀条语句
- **形式**: if (判断条件){复合语句} else {复合语句} 
- ### ctype. h 系列的字符函数
	- **isalpha()函数**的参数是⼀个字母,则返回⼀个非零值
		- 应用: if (<font color="#ffff00">isalpha(ch)</font>) 执行语句;
	- **字符映射**函数不会修改原始的参数,只会返回已修改的值
		- tolower(ch); 不改变 ch 的值
		- ch = tolower(ch);  改变 ch 的值
	- ctype.h 头文件中的**字符测试**函数 ![[Pasted image 20230917164719.png]]
		- **标准的**空白字符 (**空格,换⾏符**,换页符,回车符,垂直制表符,**水平制表符或其他本地化定义的字符**）--粗体为标准的
	- ctype.h 头文件中的**字符映射**函数 ![[Pasted image 20230917165503.png]]
- ### 多重选择 else if
	- **形式**: if (判断条件){复合语句}else if (...){...}
	- **else 与 if 配对**
		- **规则**:如果没有花括号,else 与离它最近的 if 匹配，除非最近的 if 被花括号括起来
		- 例如: else 与标记部分配对 ![[Pasted image 20230917214529.png]]
	- ![[Pasted image 20230917224132.png]]
## 2. 逻辑运算符 
- **&&与 ; ||或 ; !非**
	- `while ((status = scanf("%d", &code)) != 1 ||(code < 1 || code > 5))`
		- 在 scanf() 成功读入⼀个整数值后,才会检查 code 的值
- ### 备选拼写: iso 646. h 头文件
	- iso646.h 头文件中有可代替逻辑运算符的拼写 and 代替&&、or 代替||、not 代替!
- ### 求值顺序
	- **逻辑表达式**的求值顺序是从左往右
	- &&和||运算符都是**序列点**
	- 例如:
		- `while ((c = getchar()) != ' ' && c != '\n')`
		- `apples = (5 + 3) * (9 + 6); ` 无法确定先对 `5+3` 还是 `9+6` 求值
	- **高效性**
		- 例如: `if (number != 0 && 12/number == 2)` &&要求两个全为真,如果 number 的值是0，那么第 1个子表达式为假,且不再对关系表达式求值
		- `if (a<b||b++<a+b)` 如果 a< b 为真则跳过后一个子表达式
## 3. 条件运算符 ?:
- **三元运算符**
	- **形式**: <font color="#ffff00">表达式1 ? 表达式2 : 表达式3</font>
		- 如果表达式1为真,整个条件表达式的值与表达式2的值相同; 否则与表达式 3 的值相同
		- 例如: `x = (y < 0) ? -y : y;` 等效于 `if (y < 0) x = -y; else x = y;`
## 4. 辅助循环: continue 和 break 
- ### continue 语句
	- continue 只影响该层循环
	- *结束这轮循环, 开始下一轮循环*
	- **continue 的替换**
		- 原式: `if (score<0 || score>100){printf 语句; continue} 其他语句`
		- 例 1: `if (score<0 || score>100){printf 语句;}else {其他语句}`
		- 例 2: `if (score >= 0 && score <= 100) {其他语句}`
	- 使用 continue 的**好处**:减少主语句组中的⼀级**缩进**(替换掉了 else)
	- 用作**占位符** ![[Pasted image 20230918170115.png]]
	- 不同循环结束 continue 语句后的下一个行为
		- **while 和 do while 循环**:循环测试表达式求值
		- **for 循环**:更新表达式 (表达式 3)求值,然后对循环测试表达式 (表达式 2)求值
- ### break 语句
	- *结束该层循环, 进行下一步*
	- for 循环中的 break 语句会直接跳过更新表达式 (与 continue 中情况不同)
## 5. 多重选择: switch 和 break 
- ### switch 语句 
	- **switch 语句**:多选一 or 多选多
	- **标签**: case 'a'等
	- **形式**: ![[Pasted image 20230918172720.png]]
	- **执行过程**
		- 1.switch 后圆括号中的表达式求值
			- 圆括号和 case 标签中的值是**整数**(包括 char)
		- 2.程序扫描标签列表
		- 3.发现匹配的值跳转至那⼀⾏
			- **不**能⽤**变量**作为 case 标签
		- 4.没有匹配的标签 default
	- 注意: *continue 只能⽤于循环中*
		- C 语言的 case ⼀般都指定⼀个值,不能使⽤⼀个范围 
- ### 只读每行的首字母
	- 分析: 输入 ab 并按下 Enter 键时, ab 都进入循环并跳出 (相当于无事发生, 目的是跳过这些字符),直到读取到 Enter 键 (相当于'\\n')然后跳过该循环进入下一次读入, 则下一次读入下一行的首字母 ![[Pasted image 20230918203108.png]]
	- 为了处理第一次输入'\\n'的情况在开始时加上 `if(ch=='n')continue;`
- ### 多重标签
	- case 1: //case 2: //语句 (//表示换行)
- ### switch 和 if else
	- 根据**浮点**类型的变量或表达式来选择, 无法使用 switch
	- 判断条件是**范围** `if ( i < 10 && i  > 2 )`
## 6. go to 语句
- **组成**: goto 和标签名
	- 例如: `goto part2;` 和 `part2:printf("abc");
- ### 避免使用 goto
	- **原因**: 混乱不清, 容易犯错
	- 代替方法
		- 跳转到循环末尾,并开始下⼀轮迭代. C 使⽤continue 语句代替
		- 跳出循环,C 使⽤break 语句
	- **使用场景**
		- 出现问题时从**⼀组嵌套循环**中跳出 (break 语句只能跳出当前循环)
# 八. 字符输入输出的输入验证
## 1. 单字符 I/O: getchar putchar
- ### 介绍 getcher ()和 putchar ()
	- **getchar ()**
		- 不带任何参数, 它从输入队列中返回下⼀个字符 ch=getchar (); 等效 scanf ("%c",&ch);
		- **返回值**是输入字符对应的 ASCII 值
		- 一个 getchar 只能输入**一个字符** (执行一次只读取一个字符)
		- **换行符**'\\n'相当于 **Enter 键**
		- 与循环结合读取**字符串**
	- **putchar ()**
		- putchar (ch); 等效于 printf ("%c", ch);
	- getchar ()和 putchar ()不需要转换说明, 只处理**字符**
	- 通常是**预处理宏**, 不是真正的函数, 定义在 stdio. h 头文件
	- **注意**: 当输入 a 并按下 Enter 键时, 一个 getchar 只能读取一个字符, 换行符会缓存, 则下一个 getchar 会读取换行符 
## 2. 缓冲区
- **无缓冲(直接)输入**:输入字符后⽴即重复打印该字符
- **缓冲输⼊**:按下 Enter 键前不会重复打印刚输⼊的字符
	- 输入的字符被收集并存储在**缓冲区**(临时存储区)
- ![[Pasted image 20230918222453.png]]
- **完全缓冲 I/O 和⾏缓冲 I/O**
	- 完全缓冲输入:当缓冲区**被填满**时才刷新缓冲区 (内容被发送至目的地)
		- 应用: 文件输入
		- 大小: 常见的是 512 字节和 4096 字节
	- 行缓冲输入:出现**换⾏符**时刷新缓冲区
- **缓冲的选择**
	- C 标准规定输入是**缓冲**的
	- 一些编译器提供 **conio. h 函数**
		- **getche**(): 回显无缓冲输入
		- **getch**(): 无回显无缓冲输入
	- **回显与无回显输入**![[Pasted image 20230918225346.png]]
		- **回显**:显示正在执行的批处理命令及执行的结果
## 3. 结束键盘输入
- ### 文件, 流和键盘输入
	- **文件**
		- 含义:存储器中存储信息的区域
		- *某些程序需要访问指定的文件*
		- 引入文件, 流的**目的**: 用'EOF'代替'#'表示结束; 使 I/O 不限于键盘鼠标, 可以通过文件和流 I/O
	- **处理文件**
		- 较低层面上: C 可使⽤主机**操作系统的基本文件⼯具**直接处理文件
		- 较⾼层面上: C 可以通过**标准 I/O 包**来处理文件 (使⽤标准 I/O 包, 可避免不同的系统存储文件的⽅式不同的差异)
	- **底层 I/O**:直接调⽤操作系统的函数
	- <font color="#ffff00">C 程序处理的是流,不是直接处理文件</font>
	- **流**
		- 定义:⼀个实际输入或输出映射的**理想化数据流**
		- 用属性更**统⼀**的流来表示不同属性和不同种类的输入
		- 打开文件就是把<font color="#ffff00">流与文件相关联</font>; 文件的读写通过流完成
	- **stdin 流**表示键盘**输⼊**,**stdout 流**表示屏幕**输出** getchar()、putchar()、printf()和 scanf()函数都是标准 I/O 包的成员,处理这两个流
- ### 文件结尾
	- **检测方法**
		- 1.在文件末尾放⼀个特殊的字符标记**文件结尾**
			- 内嵌的 Ctrl+Z 字符
		- 2.存储文件大小的信息
	- scanf ()函数和 getchar()读取文件检测到文件结尾时将返回⼀个特殊的值，即EOF
		- EOF 定义在 stdio.h 文件中 `#define EOF (-1)` (一般是-1)
	- **注意:**
		- getchar()函数的返回类型是 int,如果把 getchar()的返回值赋给 char 类型的变量,可能会丢失数据
		- 在键盘输入表示 **EOF 字符**
			- **UNIX 和 Linux** 系统中,在⼀⾏开始处按下 **Ctrl+D** 会传输文件结尾信号
			- 微型计算机系统 (Windows)在⼀⾏开始按下 **Ctrl+Z**
			- 一些系统在任意位置按下 Ctrl+Z
## 4. 重定向和文件
- **默认情况**下,C 程序使⽤标准 I/O 包查找**标准输入**作为输入源(stdin 流), 将数据读入计算机
- 程序使用文件的方式
	- 1.显式使⽤**特定的函数**打开,关闭,读取,写入文件
	- 2.设计能与键盘和屏幕互动的程序,通过不同的渠道,**重定向**输入至文件和从文件输出 (即把 stdin 流重新赋给文件)
- ### UNIX, Linux 和 DOS 重定向
	- 重定向**改变了 I/O 的方式**
		- *默认是使用键盘打字通过**输入流**向该程序输入字符, 重定向后**输入流**连接文件, 文件中的字符通过输入流向程序输入字符*
		- **重定向输入**让程序使⽤文件而不是键盘;让程序输出至文件而不是屏幕
	- **处理文件**
		- 运行 c 编译后的文件 (可执行文件) `文件路径.exe`
		- 处理文本文件 (输入): `./echo_eof < words`
			- **文本文件**(.txt): 我们可以读懂的文字
		- 还有**机器语言指令**的文件不是文本文件
- ### 重定向符号
	- **重定向输入符号:<**
		- 系统 UNIX 和 DOS/Windows
		- **作用**:使 words 文件与 stdin 流相关联,把文件中的内容导入 (**输入**) 到echo_eof 程序
		- 重定向后, **文件**代替键盘屏幕成为 I/O 设备
		- **注意**: 
			- UNIX,Linux,Windows 命令提示 **<** 两侧的空格是可选的 (AmigaDOS 不能有空格)
	- **重定向输出符号:>**
		- `./echo_eof>mywords ` ⽤echo_eof 把键盘输入的内容发送 (**输出**) 到 mywords 文件中 
			- 屏幕显示的是你输入的字符, 而不是程序输出的字符
		- **作用**:创建⼀个名为 mywords 的新文件,然后把 echo_eof 的输出（输入字符的副本）**重定向**至该文件中
			- 如果存在同名文件, 会**清除**并存储
	- **组合重定向**
		- `./echo_eof < mywords > savewords` 制作 mywords 文件的副本,并命名为savewords
			- 命令与重定向运算符的**顺序无关**`./echo_eof > savewords < mywords`
			- 在⼀条命令中, 输入文件名和输出文件名不能相同
				- 原因:> mywords 在输入前已导致原 mywords 的长度被截断为0 (清除; 读取; 写入)
		- 注意: 
			- 1. *重定向运算符连接一个可执行程序和一个数据文件* (例如: 文本文档) 不可以连接两个可执行程序和数据文件
			- 2. 不能读取**多个文件**的输入, 不能把输出定向至多个文件
	- ****>>运算符**:把数据添加到现有文件的末尾
	- **| 运算符**:把⼀个文件的输出连接到另⼀个文件的输入
		- 管道运算符 (`|`) 将一个命令的输出传递给另一个命令的输入时，数据将直接流经管道，而不需要保存到文件中
- ### 注释
	- 重定向是⼀个**命令⾏概念**,要在命令⾏输入特殊的符号来发出指令
	- 不使⽤命令⾏环境,Windows 系统可以打开命令提示窗口,并在命令⾏运⾏可执⾏文件
## 5. 创建更友好的用户界面
- ### 使用缓冲输入
	- 现存问题:缓冲输入要求⽤户按下 Enter 键发送输 ⼊,这一动作也传送了换⾏符, 换行符也会被 getchar 读取
		- 例如:程序读取 n 作为⽤户否定了数字1，然后还读取了⼀个换⾏符作为⽤户否定了数字2 ![[Pasted image 20230920115525.png]]
		- 使每个答案都能有对应的回答
- ### 混合数值和字符输入
	- 假设程序要求⽤getchar()处理字符输入,⽤scanf()处理数值输入
		- 会导致第一次按下回车键后的换行符, 被第二次 while 循环中的 getchar 读取, 终止循环 ![[Pasted image 20230920124344.png]]
		- 在末尾去除多余的**空白**;scanf 后的 break 保证了输入不合理时能立即终止循环  ![[Pasted image 20230920124403.png]]
## 6. 输入验证
![[code.png]]
- 如果 get_long()函数处理这⼀⾏输入 `is 28 12.4 ` 第1个字符是非数字,那整⾏输入都会被丢弃,包括数字
- ch 的类型为 char ,会把数字当作字符
- **输入** (例如: 在键盘上打的字) 由**字符**组成, 但 scanf()可以把输入转换成整数值或浮点数值
	- 例如,输入字符"42", `scanf("%d", &x)`,那 `scanf()` 会**往%d (整数)方向**去解析这个字符,并将其转换为整数值42,然后将其存储在变量 `x` 中
- 使用转换说明 (如%d 或%f)限制了可接受输入的字符类型, 而 getchar()和使⽤%c 的 scanf()接受所有的字符
	- scanf ()使用%s 时不能读取**空白字符**, 但%c 可以
## 7. 菜单浏览
- 菜单是用户界面的一部分, 但菜单有两面性
	- 目标:⽤户遵循或**不遵循指令时**(实现难度较大)程序都能顺利运⾏
- ### 任务
	- 要获取⽤户的响应
	- 根据响应选择要执⾏的动作
	- 程序应该提供返回菜单的选项
- ### 混合字符和数值输入
![[code 1.png]]
# 九. 函数
## 1. 初识函数
- **函数**是完成特定任务的独⽴程序代码单元
	- *每个函数都能调用其它函数*
- **优点**
	- 1. 避免重复编写代码
	- 2. 让程序模块化, 便于后期修改
- ### 创建使用简单函数
	- 声明**函数原型**:告诉编译器函数 starbar()的签名
		- 形式: ![[Pasted image 20230922175128.png]]
		- **签名**: 函数的**返回值**类型;函数**接受的参数**类型
		- *函数的前置声明可以放在主调函数外也可以放在主调函数里*
	- **函数调⽤**:表明在此处执⾏函数 
		- 形式: `starbar();`
		- 执⾏到 starbar();语句时, 会找到函数的定义并执⾏其中的内容; 执⾏完后, 返回**主调函数**(main)继续执⾏下⼀⾏
	- 函数**定义**:明确地指定了函数要做什么 ![[Pasted image 20230922122629.png]]
		- 形式: `void starbar (void) {语句} ;`
	- `void starbar(void);` (用 void 表示无; 不要留空)
		- 第1个 void 是函数类型,void 类型表明函数没有返回值
		- 第2个 void (在圆括号中)表明该函数不带参数
		- 分号表明在**声明**函数,不是定义函数
	- 如果把函数放在⼀个单独的文件中，要把 # define 和 # include 指令也放入该文件
	- **局部变量**
		- 函数中的变量和函数外的变量为**同名不同变量**
- ### 带参数的函数
	- **参数类型**
		- 形式参数:**被调函数**中的变量
			- `void show_n_char(char ch, int num)` 中的 ch 和 num 为**形式参数**(形参), 形式参数也是局部变量
		- 实际参数:**主调函数**赋给**被调函数**的具体值
			- 提供了 ch 和 num 的值 `show_n_char(SPACE, 12);`
	- 文字居中: 文字前的空格数 ` spaces = ( WIDTH - strlen ( ADDRESS ) ) / 2 ; `
	- **驱动程序**:创建⼀个简单的 main(),⽤于检查 imin()是否正常⼯作;⽤于测试函数的程序
	- **返回值**
		- 主调函数 `lesser = imin(n,m);//将函数返回值赋值给lesser`
		- 被调函数中函数返回值可以是一个表达式 `return (n < m) ? n : m; `
		- 函数返回值的类型与函数声明的类型不匹配
			- 本质是 return 后面表达式或变量的值赋给了主调函数中的 lesser `return语句返回int类型的值1而不是1.23`
			- 与 `int a; a=3.14;//a为3` 是一个道理
		- `return;` 会导致终止函数,并把控制返回给主调函数
	- 没有返回值的函数应声明为 void 类型, 不声明会<font color="#ffff00">默认为 int</font>
## 2. ANSI C 函数原型
- 声明函数时**不声明函数类型**的缺点 `int imin();`
	- 可以执行但出错 ![[code 2.png]]
	- 主调函数把它的参数存储在被称为**栈**的临时存储区,被调函数从**栈**中读取这些参数
		- **主调函数**根据函数调⽤中的**实际参数**决定传递的类型, 而**被调函数**根据它的**形式参数**读取值
		- 例如: 1. 第一次读取 3 和**栈**中的其他数据; 2. 第二次按照 int 类型 (32 位)读取, 实际存入 double (64 位)
- 函数**声明**, 函数**定义**, 函数**调用**时的**变量名**相互独立
- 函数原型可以避免很多错误, 也可以不使用函数原型把函数定义放在主调函数前 (适用于小型程序)
## 3. 递归
- **递归**: 函数调用自己
	- 难点: 结束递归
	- 递归更简洁,但没有循环效率⾼
	- 缺点: 占用内存
- **过程**:fun1()调⽤fun2(),fun2()调⽤fun3();当 fun 3()结束时控制传回 fun 2(),当 fun2()结束时控制传回 fun1() ![[code1 1.png]]
	- 每级函数的变量**相互独立**(变量名相同, 但值不相同)
	- 递归调⽤前(后)的语句按被调函数(相反)的顺序执⾏
	- 递归函数必须包含能让递归调⽤**停止**的语句.如 if
- ### 递归和倒序运算
	- **尾递归**:递归调⽤置于函数的末尾 ( return 语句前)
		- **尾递归**是最**简单**的递归形式
	- **倒序运算**
		- 例如: 把十进制转化为二进制 (使用%和/) ![[code2.png]]
## 4. 编译多源代码文件的程序
- ### UNIX
	- `cc file1.c file2.c` 将编译两个文件并生成一个名为a.out 的可执行文件
	- `cc file1.c file2.o` 编译第1个文件，并与第2个文件的目标代码合并 
		- 目标文件 `file1.o和file2.o` 
	- **Linux**: 把 cc 换成 gcc
- ### Windows 和苹果的 IDE 编译器
	- IDE 中的编译器是面向**项目**的
		- 项目描述的是资源; 资源包括源代码文件
	- **单文件**:创建项目来运⾏单文件程序 (.exe)
	- **多文件**:使⽤相应的菜单命令,把**源代码文件**加入⼀个项目中
	- 要确保**所有的**<font color="#ffff00">源代码文件</font>都在**项目列表**中列出.许多 IDE 都不用在**项目列表**中列出<font color="#ffff00">头文件</font>（即扩展名为.h 的文件）
		- 项目列表 ![[Pasted image 20230923200409.png]]
		- 原因:项目只管理**使⽤的**源代码文件,源代码文件中的# include 指令管理**该文件中**使用的头文件
- ### 使用头文件
	- 把函数原型 (和已定义的字符常量)放在**头文件**中,就不⽤在每次使⽤函数文件时都写出函数原型
	- 主体文件.c, 函数定义文件.c, 常量和函数原型头文件.h
		- **主体文件**和**函数定义文件**中要包含 `#include <stido.h>和自定义的头文件#include "hotel.h"`
			- 双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）
		- 写上 `#include "hotel.h"` 相当于这个文件中包含了 hotel. h 中的语句和定义, 就*可以使用该头文件中定义的常量*且*不用再声明函数原型*
	- `scanf("%*s")` 是一个格式化输入函数 `scanf` 的调用，它的作用是**跳过并忽略**输入中的字符串
## 5. 查找地址:&运算符
- **指针**: 存储变量的地址
	- 指针的值是它所指向对象的地址,通常是该对象第⼀个字节的地址
- **函数返回值的数量**
	- *函数通常只能返回一个值*, 如果要"返回"多个值, 要使用**指针**
	- 函数中的变量是**局部变量** (函数定义中修改该值不会影响 main 中该变量的值 )
- **⼀元&运算符**
	- pooh 是变量名,那 &pooh 是变量的地址
	- PC 地址通常⽤十六进制形式表示
	- `printf("%d %p\n", pooh, &pooh);` 输出 `24 0B76`
- ### 间接运算符: `*`
	- `ptr = &pooh; `把 pooh 的地址赋给 ptr
		- 叫作: ptr“指向”pooh
		- ptr 是变量 (可修改的左值),&pooh 是**常量**(右值)
	- 使⽤**间接**运算符 (**解引⽤**运算符) `*` 找出存储在 pooh 中的值 `val = *ptr; // 找出ptr指向的值`
	- **&与 `*` 比较**
		- 地址运算符&后跟⼀个变量名时,&给出该变量的地址
		- 间接 (解引⽤)运算符 `*` 后跟⼀个指针名或地址时， `*` 给出存储在指针指向地址上的值
- ### 声明指针
	 - 声明指针必须要指定指针**所指向变量**的类型 ![[code3.png]]
	 - `int * pi;`  `pi` 是⼀个指针 , `* pi ` 是 int 类型
		 - `pi` 的类型: 指向 int 类型的指针
		 - 地址一般由无符号整数表示, 但不可以说指针是整数类型
	 - **格式**: `*` 和指针名间的空格可有可无,**声明**时⽤空格,**解引⽤变量**时省略空格
- ### 使用指针在函数间通信
	- ![[code4.png]] ![[Pasted image 20230923210307.png]]
		- 函数传递的是 x 的地址&x, 所以要定义指针变量 int* <font color="#ffff00">u</font> 接收 (并不是* x 接受) ;u 为 x 的地址
# 十. 数组和指针
## 1. 数组
- ### 初始化数组
	- 声明: int array[20]; 类型名称[数量]
		- const 只读不写 `const int days [MONTHS]`
	- `int powers[8] = {1,2,4,6,8,16,32,64};` (`[正整数表达式或变量或字面常量]`)
		- **变长数组**`int a=1;int arr[a];`
	- *数组未初始化, 空位为无用值; 部分初始化, 空位为 0; 初始化项目多于数组元素, 则错误*
		- 省略括号中的数字, 会自动匹配
		- 计算数组元素个数: `sizeof array/sizeof array[0]`
- ### 指定初始化器 (C 99)
	- 作用: 初始化指定元素
		- 传统语法: `int arr[6] = {0,0,0,0,0,212};`
		- 指定初始化器: `int arr[6] = {[5] = 212};`
	- 指定初始化器后有其他值, 会初始化指定元素后面的元素 `[6] = 4, 9, 10}` 则[7]=9;[8]=10
	- **数组元素赋值** ![[code7.png]]
- ### 数组边界
	- 使⽤越界的数组下标会导致程序改变其他变量的值 `arr[-1]替换数组后一个位置上的值` `arr[size]替换数组前一个位置上的值`
	- 使用循环遍历数组时, 使用 `i<size` `i<=size-1`
## 2.多维数组
- `int array[行][列]` (在计算机中是按顺序存储的)
	- `float rain[5][12];` 内含5个数组元素的数组，每个数组元素内含12个 float 类型的元素
- ### 初始化二维数组
	- `const int arr[2][2] = { {4,4}, {8,8} };`
	- 部分初始化后, 其余部分自动初始化为 0
	- **遍历二维数组**: 嵌套使用循环
## 3. 指针和数组
- 数组名是数组首元素的地址 `array==&array[0]`
- **指针加1**指的是增加**⼀个存储单元**
	- 加1后的地址是下一个元素的地址,不是下⼀个字节的地址
	- 将数组首元素地址赋值给指针, 指针变量加 1 相当于数组元素加 1
- 数组和指针的**关系** `arr + 2 == &arr[2] ` `*(arr + 2) == arr[2]`
	- `*(dates + 2) ` dates 第3个元素的值
	- `*dates + 2` dates 第1个元素的值加2
## 4. 函数, 数组和指针 
- 只有在函数原型或函数定义头中,才可⽤ `int ar[]` 代替 `int * ar`
	- `int ar[]` 只能⽤于声明形式参数, 定义数组时需要指定数组大小
- **声明数组形参**(函数原型可以省略参数名)
	- `int function(int *ar, int *, int ar[ ], int [ ] )`
- **函数定义中**(不能省略参数名)
	- `int function(int *ar, int ar[ ])`
- 一个数组传入函数, 函数将它当作指针, 因为数组的函数名是数组首元素的地址, 可以通过函数名加 1 解引用或者使用数组的下表来遍历
- ### 使用指针形参
	- 主函数中 `sump(marbles, marbles + SIZE);` 被调函数中循环的判断条件 `while (start < end)` 
		- `marbles ` 指向数组首元素
		- `marbles + SIZE ` 指向数组末尾后的元素 (越界)
			- 在给数组分配空间时,指向**数组后面第⼀个**位置的指针仍是**有效的指针**; 但不能访问`marbles[SIZE]`
	- ![[code8.png]]
## 5. 指针操作
- **赋值**:可以把地址赋给指针 (数组名,带地址运算符 (&)的变量名,另⼀个指针)
- **解引⽤**：`*` 运算符给出指针指向地址上存储的值
- **取址**:指针变量有⾃⼰的地址和值,&运算符给出指针本身的地址
- **指针与整数相加**:整数和指针所指向类型的⼤小 (以字节为单位)相乘,然后把结果与初始地址相加
- **递增指针**：递增指向数组元素的指针可以让该指针移动到数组的下⼀个元素
- *指针减去⼀个整数,递减指针*
- **指针求差**:通常,求差的两个指针分别指向同⼀个数组的不同元素，通过计算求出两元素之间的距离
	- 例如: ptr2 - ptr1得2,这两个指针所指向的两个元素相隔两个 int，不是2字节
- **比较**:使⽤关系运算符可以比较两个指针的值,前提是两个指针都指向相同类型的对象
---
- **解引⽤未初始化的指针**
	- 创建⼀个指针时,系统只分配了**存储指针本身**的内存,并未分配**存储数据**的内存,因此,在使⽤指针前,必须先⽤已分配的地址初始化它
- **不可以对函数名递增**函数指针的地址是固定的,无法更改
## 6. 保护数组中的数据
- ### 对形式参数使用 const 
	- 如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使⽤关键字 const `int sum(const int ar[], int n)`
		- 使⽤const 并不是要求原数组是常量, 而是该函数在处理数组时将其视为常量,不可更改
		- 指向const的指针通常⽤于函数形参中，表明该函数不会使⽤指针改变数据
- ### const 的其他内容
	- ![[code9.png]]
	- `pd++;` 让 pd 指向 rates[1] 没问题 (不能改变 pd 所指的值, 可以改变所指的位置)
	- **规则**
		- 把 const 数据或非 const 数据的**地址**初始化为指向 const 的指针或为其赋值是合法的
		- 只能把**非 const 数据的地址**赋给**普通指针**
		- 不能把 const 数组名作为实参传递给**需要修改数组元素的值**的函数
		- 把 const 指针赋给非 const 指针不安全，因为这样可以使⽤新的指针改变 const 指针指向的数据
	- **其他用法**:可以声明并初始化⼀个不能指向别处的指针 `double * const pc = array;` (指向数组的开始)
	- `const double * const pc = rates;` 该指针不能更改它所**指向的地址**,也不能修改指向**地址上的值**
		- 第一个 const 表示指向的值不能修改
		- 第二个 const 表示该指针指向的位置不能修改
## 7. 指针和多维数组
- ![[code10.png]]
	- zippo[0]是⼀个内含两个整数的数组;zippo[0]是占⽤⼀个 int 的地址,  zippo 占⽤两个 int 的地址 `zippo[0]=zippo=&zippo`
	- 给指针或地址加1，其值会增加对应类型⼤小的数值
- **比较**
	- `&zippo和zippo(==&zippo[0])和zippo[0](==&zippo[0][0]==*zippo)` 的值相等, 都为同一个地址
	- `**zippo和*zippo[0]和zippo[0][0]` 的值相等, 为 int 类型的值
- `zippo[2][1]`等价的指针表示法是 `*(* (zippo+2) + 1)`
- ![[Pasted image 20231008141241.png]]
- ### 指向多维数组的指针
	- 声明: `int (* pz)[2];` pz 指向⼀个内含两个 int 类型值的数组
		- [ ]的优先级⾼于*
		- `int * pax[2]; ` pax 是内含两个指向 int 类型指针的数组 (数组内的元素是指针)
		- 先运算什么就是什么类型
	- 可以⽤数组表示法或指针表示法来表示⼀个数组元素,既可以使⽤数组名,也可以使⽤指针名
- ### 指针的兼容性
	- 不⽤类型转换就可以把 int 类型的值赋给 double 类型的变量,但是两个类型的指针不能这样做
	- 把非 const 指针赋给 const 指针(只进⾏⼀级解引⽤)![[code12 1.png]]![[code11 1.png]]
- ### 函数和多维数组
	- 编写处理二维数组的函数
		- 1.使用 for 循环遍历数组的每一行 (无法记录⾏和列的信息)
		- 2.声明正确类型的形参变量 `void function( int (* pt)[4] );`
		- 3. `int sum2(int ar[3][4], int rows); ` 有效声明,但是3将被忽略
	- ![[code13.png]]
	- 声明⼀个指向 N 维数组的指针时,只能省略最左边⽅括号中的值 `int sum4d(int ar[ ][12][20][30], int rows);` 等价于 `int sum4d(int (*ar)[12][20][30], int rows);`
		- 第1对⽅括号表明这是⼀个指针,其他⽅括号⽤于描述指针**所指向数据对象**的**类型**
		- ar 指向⼀个12×20×30的 int 数组
## 8. 变长数组 (VLA)
- 变长数组:允许使⽤变量表示数组的**维度**
- **限制** `int r; int c; int array[r][c]`
	- 1.变长数组必须是⾃动存储类别
		- 在函数中声明和作为函数形参声明时,都不能使⽤ static 或 extern 存储类别说明符
	- 2.不能在声明中**初始化**它们
- **注意**
	- 变长数组不能改变数组的⼤小
	- ''变''指的是创建数组时,可用变量指定数组的维度
- 声明带二维变长数组参数的函数
	- `int sum2d(int rows, int cols, int ar[rows][cols]);`
	- 参数列表中:**在声明 ar 前声明 rows 和 cols**
- **变长数组**还允许**动态内存分配**，这说明可以在程序运⾏时指定数组的⼤小;**普通 C 数组**是**静态内存分配**,即在编译时确定数组的⼤小
## 9. 复合字面量
- **字面量**: 除符号常量外的常量
	- 例如: 81.3是 double 类型的字面量,'Y'是 char 类型的字面量,"elephant"是字符串字面量
		- **字符串常量**也叫作字符串字面量,可⽤于初始化字符数组
- 区别
	- 普通数组声明: `int diva[2] = {10, 20};`
	-  用复合字面量创建一个相同的匿名数组 `(int [2]){10, 20}` 等价于 `(int [ ]){10, 20}`
- **复合字面量的类型名** `int [2] ` 去掉声明中的数组名
- *为了向函数传递数组时可以直接传递, 而不是先创建再传递*
- 复合字面量要在创建的同时使用它
- 可以把复合字面量作为实际参数传递给带有匹配形式参数的函数 ![[Pasted image 20231009195200.png]]
# 十一. 字符串和字符串函数
## 1. 表示字符串和字符串 I/O
- **字符串**: 以空字符 (\\0)结尾的 char 类型数组
- **字符串常量**属于**静态存储类别**:在函数中使⽤字符串常量,该字符串只会被存储⼀次,在整个程序中一直存在
- 函数被**多次调⽤时**:双引号括起来的内容被视为指向该字符串存储位置的**指针**--<font color="#ffff00">存储字符串首字符的地址</font> (类似于把数组名作为指向该数组位置的指针)
- ### 在程序中定义字符串
	- **字符串字面量** (字符串常量)
		- 双引号中的字符和编译器⾃动加入末尾的\\0字符，都作为字符串存储在内存中
		- 例如: "I am a symbolic string constant."
		- 如果字符串字面量间没有间隔,或⽤空白字符分隔,C 会将其视为串联起来的字符串字面量
	- **字符串数组和初始化**
		- `const char m1[ ] = "abcd";` 等价于 `const char m1[ ]={'a','b','c','d','\0'}` 不完全等价于 `const char *m1 = "abcd"; `
			- **不同**:
		- 未被使⽤的元素都被⾃动初始化为0 (0指的是 char 形式的空字符,不是数字字符0)![[Pasted image 20231009213556.png]]
		- 如果创建⼀个稍后再填充的数组,就必须在声明时指定⼤小
		- `char car[10] = "Tata";` 则有 `car== &car[0]、*car == 'T'、*(car+1) == car[1] == 'a'`
	- **数组和指针**
		- `char str[ ]=''abcd'';`
			- str (数组名是常量, 要始终指向数组首元素的地址, 不可修改)
			- ''abcd''是数组在静态存储区拷贝过来的字符串常量 (**可以修改**)
		- `char * str=''abcd'';`(一般声明为 <font color="#ffff00">const</font> )
			- str 是指向静态存储区''abcd''的地址 
			- 静态存储区的字符串常量''abcd''**不可修改**
		- 声明时都使编译器为该字符串在**静态存储区**预留相应元素的空间
		- **初始化数组**:把静态存储区的字符串拷贝到数组中;**初始化指针**只把字符串的地址拷贝给指针
		- --为什么字符串要存储在静态存储区--
	- **字符串数组**
		- 字符串的存储
			- 1. 双引号, 可以理解为一个整体
			- 2. **本质**: char 类型的数组
		- 字符串数组 (将字符串作为数组的每个元素;本质是 char 类型, 只是两种不同的表现方式)
			- 1.指向字符串的指针数组 `const char *str[10]` 
				- 包含10 个字符串的数组
				- 存储的是字符串的地址 (实际上是 10 个地址)**占据 10 个地址所占字节**
			- 2.char 类型数组的数组 `char ch[10][20]` 
				- 包含 10 个含有 str_len 长度字符的数组
				- 存储的是 char 类型的数组, 每个 char 数组中都有 20个字符**占据 20 x 10 个 char 字节**
	- **两种表示方法的选择**
		- 指针表示法:只显示不修改
		- 数组表示法:需要修改原有字符串中的内容
## 2.字符串输入输出
- ### 分配空间
	- 读入字符串前要分配空间 `char name[81];` `scanf("%s", name); `
- ### gets ()和 puts ()函数
	- scanf()和转换说明%s 只能读取⼀个单词
	- **gets()函数**(C 11 废除)
		- 读取**整⾏输入**, 直到遇到换行符, 然后丢弃换行符, 在末尾**加上\\0**
		- **缺点**: 字符串过长, 会导致**缓冲区溢出**
			- c 不会报错 (一些编译器可能提示), 但可能会修改其他数据
	- **puts()函数**
		- 把字符串的**地址** (字符串数组名)作为参数传递给 `puts() `;并打印该地址上的字符, 直到字符串结尾'\\0'
		- 和 gets ()函数配对使⽤,该函数⽤于显示字符串, 并在**末尾添加换⾏符**
		- `puts(words) ` 和 `printf("%s\n", words)` 的效果相同
- ### fgets ()函数和 fput ()函数
	- **fgets() 函数**引入第二个参数**限制读取字符数**
		- 如果参数是 n 则限制读入 n-1 个字符
		- 遇到换行符, 会存储在字符串中 (fgets 对文件进行操作)
		- 第**三**个参数指明要**读入的文件**: 键盘输入为 **stdin** (标准输入)作为参数
	- *fgets()函数返回指向 char 的指针*
		- **正常**时:函数返回的地址与传入的第1个参数相同
		- 函数**读到文件结尾**:返回⼀个特殊的指针**空指针**(宏 NULL; 代码中使用 0)
			- 该指针保证不会指向有效的数据,⽤于标识这种特殊情况
	- **fputs()函数**
		- 第2个参数指明要写入文件: 显示器输出为 **stdout** (标准输出)
		- 不在结尾添加换行符 (fgets 会读取换行符)
	- ![[code14.png]]
	- 对 fgets ()使用循环可以读取更长的字符串
		- 系统使⽤**缓冲**的 I/O
		- 按下 Return 键前,输入存储在临时存储区 (**缓冲区**)
		- 按下 Return 键就在输入中**增加⼀个换⾏符**，并把整⾏输入发送给 fgets()
		- 对于输出, fputs()把字符发送给另⼀个缓冲区,当发送换⾏符时,缓冲区中的内容被发送到屏幕上
	- `while (fgets(words, STLEN, stdin) != NULL && words[0] != '\n')` fgets ()读到文件结尾或空⾏(首字符是换⾏符)时结束循环
		- 键盘输入的字符存储在缓存区; `fgets () ` 只能获取缓存区内的部分字符 (限制长度内), 获取到的字符在结尾处加'\\0'然后在缓存区清除该部分; 接着打印出该部分, 再进入 `fgets ()` 接着获取缓存区剩余的字符 (缓存区有剩余字符时不能继续输入)... 如果遇到换行符 (一行的结尾处)就不会继续读取, 而是打印出来, 然后再在缓存区获取字符, 此时缓存区没有字符, 就可以再次输入字符 (另一行)
	- **fgets ()存储换行符**
		- **缺点**:并不想把换⾏符存储在字符串中
			- 想要结束键盘输入, 必须要按下回车键产生一个换行符并存储在字符串中
			- 例如: 用两个 `fputs ()` 分**两次**在**同一行**打印出这两个字符串 (用 fgets 写入第一次内容, 用 fputs 打印出; 再用 fgets 写入第一次内容, 用 fputs 打印出)
			- **去除换行符**: `while (words[i] != '\n'){i++;} words[i] = '\0';`
		- **好处**
			- 对于存储的字符串而言，检查末尾是否有换⾏符可以**判断是否读取了⼀整行**,如果不是⼀整⾏,要妥善处理⼀⾏中剩下的字符 (例如: 未读取完一行的话, 缓存区还有字符, 要删去这些字符来保证后续读入正确的字符) `while (getchar() != '\n') {continue;} `
	- ![[code15.png]]
- ### 空字符和空指针
	- **空字符** ('\\0')标记字符串末尾,对应字符编码 0 (不是字符串的一部分)
	- **空指针**(NULL)有⼀个值,该值不会与任何数据的有效地址对应
	- *空字符是整数类型,空指针是指针类型*
	- 都可以⽤数值0来表示
- ### gets_s ()函数
	- `gets_s(words, STLEN);`
	- **特点**:
		- 只从标准输入中读取数据
		- 读到换⾏符,会丢弃
		- 输入字符串超过限制, 会直接截断丢弃 (类似 `while (getchar() != '\n') {continue;} `)然后**返回空指针**
		- 字符串过长时可能会终止或退出程序
	- **三个函数的选择**
		- 目标存储区装得下输入⾏时: `fgets()` 会保留输入末尾的换⾏符
		- 输入行过长时: `fgets () `
- ### s_gets()函数
	- 在 fgets 的基础上添加 (读取整⾏输入并用空字符代替换⾏符;或者读取⼀部分输入，并丢弃其余部分)的功能
	- ![[code16.png]]
- ### scanf ()函数
	- 从第1个非空白字符开始, 到下一个空白字符结束
	- scanf()函数返回⼀个整数值,该值等于 scanf() 成功读取的**项数**或 EOF（读到文件结尾时返回 EOF）
	- **缺点**:输入行的内容过长，scanf()会导致数据溢出
		- 在%s 转换说明中使用字段宽度可防止溢出
- ### printf ()函数
	- printf()也把字符串的**地址**作为参数
		- `printf("%s\n", string);` string 是数组首元素的地址 (是一个**地址**)
		- `printf("abc");` 会直接打印 "abc"，而不涉及变量或地址的处理
	- printf()打印多个字符串更加简单 `printf("Well, %s, %s\n", name, MSG);//打印在一行`
	- *使用变量间接打印字符串: 本质都是以地址作为参数*
## 3. 自定义输入输出函数
- ![[code17.png]]
## 4. 字符串函数 
- <string.h> 头文件 `strlen()、 strcat()、strcmp()、strncmp()、strcpy()、strncpy()`
- <stdio.h> 头文件 `sprintf()`
	- **拼接**: `strcat () `
	- **比较**: `strcmp()` 
	- **赋值**: `strcpy()`
- ### strlen ()函数
	- 用法:统计字符串的长度![[code18.png]]
- ### strcat ()函数
	- **作用**:拼接字符串 (接受**两个字符串**作为参数)
	- **用法**: `strcat (str 1, str 2); ` 
		- 将 str2 的备份加到 str 1 的末尾, (去掉 str 1 末尾的'\\0'), 拼接后的新字符串代替 str 1; str 2 不变
		- `str 1 ` 数组一般会指定存储元素的数量, 如果让系统自动匹配 (使用 `[ ]`)将无法容纳 ` str 2 `
	- **strcat()函数**的类型是 char * :就是返回一个**指针**
		- strcat ()函数返回第 1 个参数 (str 1 的地址)
	- **缺点**:无法检查第1个数组是否能容纳第2个字符串
- ### strncat ()函数
	- `strncat(str1,str2,n)` (`n = SIZE - strlen(str1) - 1;`)第3个参数限制 (str 2)最大添加字符数 (即,在加到第 n 个字符或遇到空字符时停止)
	- 也可以⽤strlen()查看第1个数组的长度 `if ((strlen(str1) + strlen(str2) + 1) <= SIZE)`
- ### strcmp ()函数
	- 把⽤户的响应与已存储的**字符串作比较**
		- 直接使用数组名与**字符串**比较本质上比较的是**地址**(指针表示法可以比较, 但指针表示法必须要初始化)
	- **返回值**
		- 两个字符串参数相同, 返回 **0** (数字比较相等的话是 1, 该函数是返回 0)
		- 在字母表中第1个字符串位于第2个字符串前，strcmp()中就返回负数 (返回 **ASCII 码之差**)
	- `while (strcmp(try, ANSWER))` 表示当他们不同时, 进入循环
	- **注意**:strcmp()函数比较的是字符串，不是字符
- ### strncmp ()函数
	- `strncmp(str, "abcde", 5); ` 第三个参数限制比较的数量
- ### strcpy ()函数
	- **作用**:拷贝字符串 (**也会拷贝'\\0'**)
	- pts1和 pts2都是指向字符串的指针 `pts2 = pts1; ` 这句话拷贝的字符串的**地址** 
	- `strcpy (str1, str2); ` `str1` 叫作**目标字符串**; `str2` 叫作**源字符串** 
		- 返回值: `str1` 的地址
		- `str2 ` 可以是字符串常量 `strcpy(str1, "Hi ");`
		- `str1` 要提前初始化 (留好空间) *避免使用指针来声明字符串数组*
		- 第1个参数 (指针)不必指向数组的开始, 例如: `po = strcpy(str1 + 1, "hi");`
	- **注意**:
		- 第1个指针应指向⼀个数据对象 (如,数组),且该对象有足够的空间存储源字符串的副本
		- **声明数组**会分配存储数据的空间,**声明指针**只分配存储⼀个地址的空间
- ### strncpy ()函数
	- **作用**:检查目标空间是否能**容纳**源字符串的副本
		- 第3个参数指明可拷贝的最⼤字符数
	- `strncpy(target, source, n); ` 把 source 中的 n 个字符或空字符之前的字符拷贝到 target 中
		- 如果拷贝到第 n 个字符时还未拷贝完整个源字符串,就不会拷贝空字符
		- 对于过长的 source, 一般把 n 设置为比目标数组⼤小少1 `n=TARGSIZE-1`, 然后在字符串副本的**末尾添加一个 '\\0'**
- ### sprintf ()函数
	- 定义在 `stdio.h` 中,把数据写入字符串, 而不是打印在显示器上
	- **作用**: 可以把多个元素组合成⼀个字符串 (可以使用转换说明存储其它类型的变量)
	- `sprintf(tag_str, "%s %d\n", str1, int1);` 将应该显示到屏幕上的字符串存储到 `tag_str ` 中 (本质上传递的是**地址**)
- ### 其他字符串函数
	- *判断**字符串**中是否包含某个**字符***
		- 1. `char *strchr(const char * s, int c);` 如果 s 字符串中包含 c 字符,该函数返回 (首次出现的) 该字符的**地址**（包括空字符）; 否则返回空指针
			- 用法: `ch = strchr(line, '\n');`
		-  2. `char *strrchr(const char * s, char c); ` 该函数返回 (最后⼀次出现的) 该字符的**地址** (包括空字符)
	- *判断**两个字符串**中是否有**相同**字符*
		-  `char *strpbrk(const char * s1, const char * s2);` 如果 s1字符中包含 s2字符串中的任意字符，该函数返回 s1 字符串首位置的**地址**; 否则返回空指针
			- 用法: `ch=strpbrk("abc","cde")`
	- *判断一个**字符串**中是否包含另一个**字符串*** 
		- `char *strstr(const char * s1, const char * s2);` 该函数返回指向 s1字符串中 s2字符串出现的**首位置**;否则返回空指针
			- 用法: `ch=strstr("abcde","abc")`
## 5. 字符串示例: 字符串排序
- ![[code19.png]]
- 程序的巧妙之处在于排序的是指向字符串的指针，而不是字符串本身
- **选择排序**
	- for n = 首元素到 n = 倒数第2个元素, 找出剩余元素中的最⼤值，并将其放在第 n 个元素中 ![[Pasted image 20231013103629.png]]
## 6. ctype. h 字符函数的字符串
- ![[code20.png]]
## 7. 命令行参数
- **命令行**:在命令行环境中，⽤户为运⾏程序输入命令的⾏
- 运行名称为 fuss 的程序
	- UNIX 系统: `$ fuss`
	- Windows 系统: `C> fuss`
- **命令⾏参数**: 同一行的附加项
- ### main ()函数中的参数
	- **形式**: `int main(int argc, char *argv [])` 
	- **目的**:与命令行产生交互, 把命令行中的**字符串**和**字符串个数**传入 `main()` 函数中 ![[Pasted image 20231013223627.png]]
	- `argc` 是在命令行中字符串的数量 (字符串之间用空格隔开, 也可⽤双引号把多个单词括起来形成⼀个参数)
		- 例如: `C>repeat "Resistance is" futile`  `argc ` 是 3; `argv` 中有三个**指针** (指向字符串常量)
		- `argv[0] ` 是程序本身的名称, 这里是 `repeat` 
		- `argv[1]` 指向 `Resistance is`
		- `argv[3]` 指向` futile `
	- `char * argv[] ` 是指针数组 (组成元素是指针的数组)
		- 存储输入的字符串的**地址**
	- **其他声明方式** `int main(int argc, char **argv)`
		- `char **argv` 与 `char *argv[]` 等价
		- `argv` 是⼀个指向指针的指针, 它所指向的指针指向 char (类似于字符串数组)
## 8.把字符串转换为数字
- 数字既能以**字符串**形式存储，也能以**数值**形式存储
	- **数值**形式: 进⾏数值运算
		- *编写程序*时使用的数字为对应的数值
		- 例如: `a=b+1;` 这里的 1 不是字符串
	- **字符串**形式: 在屏幕上<font color="#ffff00">显示</font>数字
		- *运行程序*时, 需要输入和输出的数字本质是字符串
		- 例如: `scanf ("%d", &a) ` 中输入的数字是字符串, 会在内部转化为数值后传递给 a
- `printf()` 和 `sprintf()` 函数,通过 `%d ` 和其他转换说明，把数字从数值形式转换为字符串形式
	- `%d ` 告诉系统,这个变量是 int 类型的值, 是将 int 类型 (而不是其他类型)转换为字符串; 而不是按照其他类型的转换规则
- `scanf()` 可以把输入**字符串**转换为**数值**形式
- ### 字符串转化为数值的一系列函数 
	- 引入这些函数的**原因**: 如果程序需要使用命令行参数 `argv ` 传递数值, 但是在命令行输入数值只能传递字符串
		- 一般向程序传递数据的函数 (如: `scanf` )会将在屏幕上输入字符串转化为数值
		- *程序需要使用命令行参数 `argv ` 传递数值* 例如: 打印字符串 `str1` 5 次, 则需要传入 `str1` 和数值形式的 5
	- **atoi()函数**
		- **作用**:把字母数字转换成整数( 定义在 `stdlib.h` 中)
		- **函数原型**: `int atoi( char * str )` 接受⼀个字符串作为参数，返回相应的整数值![[code21.png]]
		- `atoi ("42abcd")` 返回 42; `atoi("abcd")` 返回 0 (此行为未定义)
		- **类似函数**
			- `atof()` 把字符串转换成 double 类型的值
			- `atol()` 把字符串转换成 long 类型的值
	- **strtol()函数**
		- **作用**:把字符串转换成 long 类型的值 ( 定义在 `stdlib.h` 中)
		- 相较于 `atoi` 的优点:
			- 1.可以识别和报告字符串中的**首字符**是否是**数字**
			- 2. `strtol()` 和 `strtoul()` 可以指定数字的进制
		- **函数原型**: `long strtol( char * str, char ** str, int a);`
			- `char * str ` 待转换字符串的指针
			- `char **str` 输入数字结束后第一个字符 (这个字符本质是指针, 存储字面量的地址)的**地址**
				- 一般在调用函数前声明一个指针 `char * end` 作为第二个参数来存放这个地址, 以便后面*打印未转换为数值的剩余字符串*; 例如: `strtol(number, &end, 16);`
			- `int a` 表示以什么进制写入数字
		- **类似函数**
			- `strtoul()` 把字符串转换成 unsigned long 类型的值
			- `strtod()` 把字符串转换成 double 类型的值
		- **注意**
			- 1. `strtol()` 函数最多可转换三十六进制 'a'~'z'字符都可用作数字
			- 2. `strtoul()` 函数与 `strtol()` 类似,但它把字符串转换成无符号值 
			- 3. `strtod()` 函数只以十进制转换,只需两个参数\
	- *数值转化为字符串* 使用 `sprintf ()` 函数
# 十二.存储类别,链接和内存管理
## 1.存储类别
- **硬件方面**: 被存储的值占用一定的物理内存, 这块内存称为**对象**
	- 对象可以存储⼀个或多个值
	- ⼀个对象可能并未存储实际的值,但它在存储适当的值时⼀定具有相应的⼤小
- **软件方面**: 可以通过声明变量
	- `int a;` 该变量创建了一个名为 a 的**标识符**(一个名称)在这种情况下, 标识符可用来**指定**特定对象的内容 (标识符用于访问对象)
	- `int * pt = &entity;` pt 是⼀个标识符,它指定了⼀个存储地址的对象;表达式 `*pt` 不是标识符, 但它指向了一个对象
- 指定对象的表达式被称为左值
	- **可修改的左值**: 可以使用左值改变对象中的值
	- `const char * pc = "Behold a string literal!";` const 只能保证被 pc 指向的字符串的内容不被修改
- **存储期**:对象在内存中保留的时间
- ### 作用域
	- **作⽤域**:描述程序中可访问标识符的区域 (包括块作用域, 函数作用域 (go to), 函数原型作用域, 文件作用域)
	- **块作用域**
		- **块**: 用一对花括号括起来的代码区域
		- **块作⽤域变量**:从定义处到包含该定义的块的末尾
		- 1.整个函数体是⼀个块,函数中的任意复合语句也是⼀个块
		- 2.函数的*形式参数声明* 也具有块作⽤域,属于函数体这个块
		- 3.*for 循环、while 循环、do while 循环和 if 语句* 圆括号中的变量也属于函数块里面
	- **函数原型作用域**:函数原型中的形参名 (变量名)
		- **范围**:从形参定义处到原型声明结束
		- 变长数组中: `void ar(int n, int m, ar[n][m]);` ⽅括号中必须使⽤在函数原型中已声明的名称
	- **文件作⽤域**:变量的定义在函数的外面
		- **范围**:定义处到该定义所在文件的末尾
		- 具有文件作用域的变量称为**全局变量**
	- 编译器把<font color="#ffff00">源代码文件</font>和<font color="#ffff00">所有的头文件</font>都看成是⼀个包含信息的单独文件,这个文件被称为**翻译单元**
		- 描述⼀个具有**文件作⽤域**的变量时，它的实际可见范围是整个翻译单元
- ### 链接
	- **分类**:外部链接,内部链接,无链接
	- **无链接变量**
		- 具有块作⽤域,函数作⽤域,函数原型作⽤域的变量
	- **外部链接与内部链接**
		- 具有文件作⽤域的变量
		- **外部链接变量**可以在**多文件程序**中使⽤
		- **内部链接变量**只能在**⼀个翻译单元**中使⽤
	- 另一种叫法:
		- **内**部链接的文件作⽤域--**文件作⽤域**
		- **外**部链接的文件作⽤域--**全局作⽤域,程序作⽤域**
	- **存储类别说明符** `static`
		- `int giants = 5;` (在 mian 函数外部定义的变量)--文件作⽤域,外部链接
			- 该文件和同⼀程序的其他文件都可使⽤
		- `static int dodgers = 3;` (在 mian 函数外部定义的变量)--文件作⽤域,内部链接
			- 该文件中的任意函数都可使⽤
- ### 存储期
	- **分类**:静态存储期,线程存储期,⾃动存储期,动态分配存储期
	- **静态存储期**:
		- **存在周期**:在程序的执⾏期间⼀直存在
		- <font color="#ffff00">文件作⽤域变量</font>具有静态存储期
		- **注意**:
			- 关键字 `static` 表明了其链接属性, 不是存储期
	- **线程存储期**
		- **并发程序设计**:程序执⾏可被分为多个线程
			- 以关键字 `_Thread_local` 声明⼀个对象时，每个线程都获得该变量的私有备份
		- **存在周期**:从被声明时到线程结束⼀直存在
	- **⾃动存储期**:
		- **存在周期**: 进入块时分配内存, 退出块时释放内存
		- <font color="#ffff00">块作⽤域的变量</font>通常都具有⾃动存储期
		- **注意**:
			- 变长数组的存储期:声明处到块的末尾 (不是从块的开始处到块的末尾)
		- 到目前为止使⽤的局部变量都是**⾃动类别**
		- `static int ct = 0;` *块作⽤域变量也能具有静态存储期* : 可以在其他函数中使用指针对他操作
	- ![[Pasted image 20231021130427.png]]
- ### 自动变量
	- 定义方式: 函数内
	- **特点**:⾃动存储期,块作⽤域, 无链接
	- 关键字 `auto` (存储类别说明符): 定义自动存储类别的变量 `auto int plox;` (只能⽤于块作⽤域的变量声明中)
	- **嵌套块**:块中声明的变量仅限于该块及其包含的块使⽤
		- 内层块中声明的变量与外层块中的变量同名: *内层块会隐藏外层块的定义* 离开内层块后恢复原有的声明
	- **没有花括号的块**: (循环和 if 语句)
		- **子块**:{花括号}中的内容=>整个循环语句=>该函数
	- **⾃动变量的初始化**
		- ⾃动变量不会初始化, 需要显式初始化. 例如: `int a=1;`
- ### 寄存器变量
	- `register int quick;` 当寄存器空间充足时会存储在寄存器中 (只能⽤于块作⽤域的变量声明中)
		- 可以在函数头中使用 `void macho(register int n)` 
	- **特点**:块作⽤域,无链接,⾃动存储期
	- 优点: 速度快
	- 缺点: 不能取地址符 `& `
- ### 块作用域的静态变量 (静态局部变量)
	- **定义方式**: 函数内, 使用 `static` (`static` 表示静态存储类别, 不会被删除) ![[Pasted image 20231021152518.png]]
	- **特点**:块作⽤域,无链接,静态存储期
		- 离开声明该变量的块后, 不会消失但无法在其他块中直接使用 (可以使用指针)
	- `int wontwork(static int flu);//不允许` 不能在函数的形参中使⽤ `static`
	- **作用**:一般放在函数内统计函数运行次数
- ### 外部链接的静态变量 (外部变量)
	- 定义方式: 函数外
	- **特点**: 文件作⽤域,外部链接,静态存储期
	- `extern int Errupt;` 在函数中可以⽤关键字 extern 再次声明 (可写可不写)
	- `extern double Up[];` 数组的再次声明--不⽤指明数组⼤小
	- **初始化外部变量**:
		- 可以被显式初始化, 未初始化会默认为 0
		- 与⾃动变量的情况不同,只能使⽤**常量表达式**初始化<font color="#ffff00">文件作⽤域变量</font>
			- `int a=1; int b=a; ` 错误, a 为变量
			- sizeof 表达式可被视为常量表达式 (除了变长数组)
	- **定义和声明**
		- *外部变量只能初始化⼀次* ，且必须在定义该变量时进⾏; 但可以修改值, `extern int a=1;//错误` `a=1;//可以`
		- 定义式声明: `int tern = 1;` 
		- 引⽤式声明: `extern int tern;`
- ### 内部链接的静态变量 (静态全局变量)
	- 定义方式: 函数外, 使用 static (static 表示只能在该文件中使用)
	- **特点**:静态存储期,文件作⽤域,内部链接
	- `extern int traveler;` 也可以在函数内使用 extern 
- ### 多文件 
	- **翻译单元**: 一个源文件和所有的头文件
	- 多文件:多个单独的源代码文件
	- **注意**:
		- 1. 使用 `#include <文件>` 包含文件
		- 2. 除了⼀个定义式声明外，其他声明都要使⽤extern 关键字 (只有定义式声明才能初始化变量)
		- 3. 如果外部变量定义在一个文件中,其他文件在**使⽤该变量前必须先声明它** (⽤extern 关键字)-- *单文件时可以不用 extern; 其他文件使用时需要 extern*
- ### 存储类别说明符 
	- 关键字 `static` 和 `extern` 的含义取决于上下文
		- `static`**文件作用域**:表明文件作用域变量链接属性 (有链接或无链接), 不是存储期
		- `static`**块作用域**: 表明块作用域的存储期
	- **存储类别说明符**: `auto , register , static , extern , _Thread_local , typedef`
		- `_Thread_local` 可以和 `static` 或 `extern` ⼀起使⽤
		- `static`
			- 1.**作用域**: 文件作用域声明,作⽤域受限于该文件;块作⽤域声明,作⽤域则受限于该块
			- 2.**链接**:块作⽤域的静态变量无链接;⽂件作⽤域的静态变量具有内部链接
			- 只要程序在运⾏对象就存在并保留其值，但只在执⾏块内的代码时,才能通过标识符访问
		- `extern` (表明声明的变量定义在别处)
			- 1.包含 extern 的声明具有文件作⽤域，则引⽤的变量必须具有外部链接 (引用的其他文件的变量)
			- 2.包含 extern 的声明具有块作⽤域,则引⽤的变量可能具有外部链接或内部链接 (可能是该文件中的或其他文件中的)
	- **局部变量和全局变量**
		- **局部变量 (定义在函数内)**: 自动变量, 寄存器变量, 静态局部变量 (在函数内声明且有 `static`)
		- **全局变量 (定义在函数体外部)**: 静态全局变量 (在函数外声明且有 `static`), 外部变量
- ### 存储类别和函数
	- **分类**
		- **外部函数** (默认, 也可以加上 ` entern `)--可被其他文件的函数访问
			- `extern double delta(double, int);`
			- `double gamma(double);`
		- **静态函数** (` static `)--只能当前文件使用
			- `static double beta(int, int); `
		- **内联函数**
	-  `extern` 和 `static` 用于声明和定义

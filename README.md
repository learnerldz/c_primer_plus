# c_primer_plus
# 一.初识 C 语言 
## 1 .C 语言的起源
- 1972年,贝尔实验室的**丹尼斯·里奇**和**肯·汤普逊**在开发 **UNIX 操作系统**时在**B 语言**的基础上设计了 **C** 语言
## 2. 选择 C 语言的理由
- ### 设计特性
	- 易懂,可靠
- ### 高效性
	- 相对紧凑;运行时间快
	- 微调控制能力**汇编语言**特性（可以根据具体情况**微调程序**获得**最大运行速度**或**最有效**地使用内存）
		- **汇编语言**: 为特殊的中央处理单元设计的⼀系列内部指令, 使用助记符来表示
			- 不同的 CPU 系列使用不同的汇编语言
- ### 可移植性
	- 意味着：**在⼀种系统中编写的 C 程序稍微修改就可以在其他系统运行**
		- **编译器**:把 C 代码转换成计算机**内部指令**的程序
- ### 面向程序员
	- **优点**:许多任务用 C 来处理都非常**简洁** (例如:转换数据的格式）
	- **缺点**: C 语言使用**指针**, 易犯错, 难察觉
## 3.C 语言的应用范围
- C 语言是**嵌入式系统编程**的流行语言
- C 语言从长期被 FORTRAN 独占的**科学编程领域**分得一杯羹
- **UNIX 操作系统**, 大部分是用 C 语言写的
- 其他语言 (如 FORTRAN, Perl, Python、Pascal, LISP, Logo, BASIC)的许多**编译器**和**解释器**都是用 C 语言编写的
## 4. 使用C 语言的7个步骤
- 1. 定义程序的目标; 2. 设计程序; 3. 编写代码; 4. 编译; 5. 运行程序; 6. 测试和调试程序; 7. 维护和修改程序
	- **运行程序**需要**集成开发环境**(IDE)
	- **调试**:查找并修复程序错误的过程
## 5.编程机制
-  ![[Pasted image 20230914170820.png]]
- **源代码文件**:编写程序时, 存储*源代码*(编写的内容)的文本文件
- **目标代码文件**:存储机器语言代码 (由源代码转换)的文件
	- 基本名:点号 (.)前面的部分
	- 扩展名:点号后面的部分
- **启动代码**:程序和操作系统间的接口
- **链接器**的作用:把编写的目标代码(大括号内的代码),系统的标准启动代码（`#include <stdio.h >` 和 `int main()`）和库代码合并成<font color="#ffff00">可执行文件</font>
	- 链接器只提取程序中要用到的**库函数代码**
	- **可执行代码**: 用计算机的**机器语言**表示的代码
- **编译器**:把 C 代码转换成计算机**内部指令**的程序
# 二.C 语言概述
## 1. 代码含义
- ![[Pasted image 20230901014006.png]]
-  `#include<stdio.h>` 告诉编译器把 stdio. h 中的内容包含在当前程序 
	- `#include <stdio.h>` 是一条 C **预处理器指令**
	- stdio.h (**标准输出/输入头文件**)包含编译器使用的函数信息
-  `int main(void)` 函数是 C 程序的基本模块
	- main()是函数名
	- int 表示 main()函数返回一个整数 
	- void 表示 main()不带任何参数
	- 旧式的代码会出现 `main()` 和 `void main()` 
- `/*这是一段的注释*/` 和 `//这是一行的注释` 编译器会忽略
-  `{这里面是函数体}`; `int num` 声明变量类型; `num=1;` 赋值表达语句;
	- 花括号{}还可用于把函数中的多个语句合并为有一个单元或块 (复合语句)
	- **声明**是 C 语言最重要的特性之一; `int` 是 C 语言中的一个**关键字**; `num` 是一个**标识符**
- **命名**
	- 能清楚地表达自身的用途
	- 可以用**小写字母, 大写字母, 数字, 下划线** (`__`) 来命名
	- 首个字符必须是字母或下划线; 不能是数字
	- 不能使用**关键字**和**保留标识符**
- **声明变量**: 未提前声明变量,将无法通过编译
- **调用函数**: 在程序中使用函数
- **预处理**: C 编译器在编译前对源代码做的准备工作
- **头文件**: 在 C 程序顶部的信息集合
-  `return 0;` 在有返回值的函数中一定要有 
## 2. 提高程序的可读性  
- 选择有意义的函数名和写注释  
- 在函数中用空行分隔概念上的多个部分  
- 每条语句各占一行  
## 3. 多个函数     
- **程序状态**:在程序的执行过程中,某给定点上所有变量值的集合  
- **调试器**是一种程序,可逐步运行一个程序,并检查该程序变量的值
## 4. 关键字和保留标识符  
- **关键字** ![[Pasted image 20230903173848.png]]  
- **保留标识符**包括以下划线字符开头的标识符和标准库函数名,如 printf()
# 三. 数据和 C  
## 1.变量与常量数据  
- **常量**: 在程序使用前就设定好,程序运行过程中无变化  
- **变量**: 在程序运行期间可能会改变或被赋值  
## 2. 数据: 数据类型关键字  
- int long short unsigned char float double signed void `_Bool` `_Complex` `_Imaginary ` 
- **关键字含义**
	- signed 用于提供基本整数类型的变式,例: unsigned short int 和 long long int  
	- char 关键字用于指定字母和其他字符（如:# $ % `*`）和较小的整数
	- float、double 和 long double 表示带小数点的数 
	- `_` Bool 类型表示布尔值 (true 或 false), `_  Complex ` 和  `_ Imaginary ` 分别表示复数和虚数
- **位,字节,字**
	- **位** (bit)存储 0 或 1
	- **字节**一个字节为 8 位;有 256 种可能
	- **字** 设计计算机时给定的自然存储单位,大多数为 32 位和 64 位
- **整数**: 没有小数部分的数
- **浮点数**: 实数 (带小数部分)
## 3. C 语言的基本数据类型  
- ### int 类型 (有符号整型)  
	- 取值范围 16 位为-32768~32767 (-2<sup>15</sup>~2<sup>15</sup>-1)  
	- **初始化变量**: 为变量赋一个初始值  
	- %d (十进制);%o (八进制); %x (十六进制) 打印变量  
		- 显示各进制数的前缀0、0x 和0X 需要加# `% #o`  例如: 3F 使用 `%X`; OX3A 使用 ` % #X ` (# 数字前加上 OX)
- ### 其他整数类型  
	- **short int** `%hd` 常用于较小数值的场景节省空间 (有符号) 16 位  
	- **long int** `%ld` 较大的数比较占用空间 (有符号) 16 位或者 32 位(*一般为 32 位*)  
	- **long long** `%lld;%llu;%#llo;%#llx` 占据64 位 (有符号)  
	- **unsigned int** `%u` 为正整数 (无符号) 16 位的范围 (0~2<sup>16</sup>-1)  
	- *signed 是强调使用有符号类型的意图可以省略*
	- long 常量  
		- 八进制和十六进制常量被视为 int 类型  
		- 如果数值过大依次使用unsigned int、long、unsigned long、long long 和 unsigned long long 类型  
		- 把⼀个较小的常量作为 long 类型对待: 在值的末尾加上 l 或者 L 后缀 (也可用于八进制和十六进制)
			- 同理: long long 为 LL 后缀; unsigned long long 为 ULL  
	- **整数溢出**(溢出行为是未定义行为)
- ### 使用字符: char 类型
	- 实际上存储的是整数.例如:在 **ASCII 码**中,整数65 代表大写字母 A  
		- **ASCII 码**:0~127 由七位二进制数表示
			- 48~57 表示'0'~'9'
			- 65~90 表示'A'~'Z'
			- 97~122 表示'a'~'z'
		- **char 类型**为 8 位存储单元  
	- **字符常量初始化**  
		- 例如: `char grade = 'A' ` 必须要加单引号  
		- 在 C 语言中,用单引号括起来的单个字符被称为**字符常量**![[code6.png]]  
		- 对于'ABCD'把四个独立的 8 位 ASCII 码存储在一个 32 位中 *但把'ABCD'赋值给 char 则 char 为'D'   
	- **非打印字符**  
		- 注意:\\Ooo 前面的 O 可以省略 也表示八进制 ![[Pasted image 20230905180749.png]]  
		- **行为字符表示方法**
			- 1. 使用 ASCII 码 `char beep = 7`
			- 2. 使用特殊的符号序列 (见上图: **转义序列**) `char ner = '\n' `
				- 报警字符不得改变**活跃位置**(显示设备中下一个字符将出现的位置)![[Pasted image 20230905182923.png]]
			- 3. 用十六进制形式表示字符常量 ('\\xF')
				-  反斜杠后面跟⼀个 x 或 X,再加上1~3位十六进制数字
	- **打印字符**(%c)
	- **有符号还是无符号**
		- 可以在 char 前加上 signed (有符号) 或 unsigned (无符号)
		- 无符号的 char 类型在处理小整数时很好用
- ### -Bool 类型 
	- 表示**布尔值** (逻辑 true 1 和 false 0)
	- 也是一种整数类型,原则上占一位
- ### 可移植类型: stdint. h 和 inttypes. h 
	- stdint.h (*可以不用 stdint.h 使用 int32_t 移植的话需要使用 stdint.h*)
		- **精确宽度整数类型**
			- int32_t  (这些是前缀)
			- 整数类型的宽度正好是32 位
			- 计算机底层可能不支持
		- **最小宽度类型**
			- int_least8_t
			- 可容纳8位有符号整数值的类型中宽度最小的类型
		- **最快最小宽度类型**
			- int_fast8_t
			- 系统中对8位有符号值而言运算最快的整数类型
			- 可使计算达到最快的类型
		- 其他
			- 最大的有符号整数类型**intmax_t**
			- 最大的无符号整数类型**uintmax_t**
	- inttypes. h
		- PRId32 字符串宏来打印 int32_t 类型的值 
	- ![[Pasted image 20230906164743.png]]  
		- 该程序最后⼀个 printf()中，参数 PRId32被定义在 inttypes.h 中的"d"替换等价于: ![[Pasted image 20230906164854.png]] 多个连续的字符串组合成一个字符串![[Pasted image 20230906165045.png]]  
- ### float、double 和 long double 
	- 计数法 ([[计算机科学导论#^296905|存储方式]])
		- 科学计数法: 1.0 x 10<sup>9</sup>
		- 指数计数法: 1.0e9 或 1.0E9 (不可以加空格)
	- float: 32 位表示 8 位指数 1 位符号 23 个尾数 (有效数)![[Pasted image 20230824025433.png]]  
	- double: 64 位表示 11 位指数 1 个符号 52 个尾数![[Pasted image 20230824025454.png]]  
	- **浮点数常量**
		- 正号可以省略; 小数点和指数不可同时省略 
		- 在程序中可以 1.0 或者 1E2 (无空格) 表示
		- *输入的浮点数默认为 double* 可以加后缀 f 来表示 float l 表示 long double
			- **添加 f 后缀的好处**: 2.0 x 2.0 运算时为两个 double 类型 结果需要截断 (影响速度) 而两个 f 则不需要
		- **十六进制表示**
			- 加上 ox 前缀; 用 p 和 P 代替 e 和 E .例如: oxa.1fp10 表示十六进制的 a.1f x 2<sup>10</sup>
			- p 是指 2 的幂; e 是 10 的幂
	- **打印浮点值**
		- **%f** 打印**十进制**的 float 类型
		- **%e** 打印**指数**计数法的浮点数
			- printf 打印出的形式: `1.234E+09`
		- **%a** 打印**十六进制的指数**计数法的浮点数
		- 在前面加上 l 可打印对应的 long 类型
			- **%lf** 打印 **long double**
	- **浮点值的上溢和下溢**
		- 上溢 (现在会输出*无穷大*)
		- 下溢 (损失精度 可能出现较大误差 下溢后输出 nan 或 NAN)
		- **舍入错误**: 精度不够导致某几位上的数据丢失
		- [[计算机科学导论#^c95a9e|上溢和下溢的详细介绍]]
- ### 复数和虚数类型 
	- *3 种复数类型* 
		- float_Complex (包含**两个** float 的值 分别表示**实部和虚部**)
		- double_Complex
		- long double_Complex
	- *3 种虚数类型*
		- float_Imaginary
		- double_Imaginary
		- long double_Imaginary
	- complex. h 头文件中可以用 complex 代替_Complex; imaginary 代替_Imaginary 用 I 代替-1的平方根  
		- 例如: float complex a = x x x ;
		- 为何 C 标准不直接用 complex 作为关键字来代替_Complex?
		   *因为在此之前有许多人用到了 complex因此它不能变成关键词*
- ### 其他类型 
	- 字符串  数组  **指针**  结构  联合
	-  **声明变量**
		- 可以同时声明多个变量: ![[Pasted image 20230907024222.png]]
		- 可以在声明变量的同时初始化变量: ![[Pasted image 20230907024258.png]]  
## 4. 使用数据类型  
- ![[Pasted image 20230907150239.png]]  
	- C 编译器把浮点数转换成整数时,会**丢弃小数部分不会四舍五入**
		- 例如: int a=3.1 则 a=3 (在赋值时会出现这种情况)
		- 但是在 **printf** 和 **scanf** 中 ("%d", 3.1) 则会出错,而不是 3
	- C 只保证了 float 类型前六位的精度
	- 允许编写**混合数据类型**的表达式 (例如: `int a=1;printf("%lf",a*1.1);` 这时输出 1.1 而不是 1; a x 1.1 为 double 类型)
- 大多数情况下有以下约定
	- 用 i_前缀表示 int 类型 ; 例如: i_smart  
	- 用 us_前缀表示 unsigned short 类型 ; 例如:us_versmart
## 5. 参数和陷阱 
- printf ()括号中的**一个字符串**为一个参数
	- 但是参数是可变的例如: printf ("%d %d", a ,b); 这其中就有 3 个参数
	- **参数**之间用**逗号**隔开
- scanf ("%d"&a); 为两个参数
- *注意参数的数量类型相匹配*
## 6. 转义序列 
- 可以定义 char 字符类型使用
	- char a='\\n';
	- printf ("%c" a);
- 也可以直接在 printf 中当作字符使用 (printf 双引号内的是**字符串**)
	- printf ("\\n")
- *一些转义字符可能与现代的图形接口兼容*
- **刷新输出**
	- 最初 printf ()语句把输出发送到**缓冲区**(中间存储区域), 然后发送到屏幕
	- **刷新缓冲区**: 缓冲区的数据发送到屏幕或文件
	- C 标准规定: 当*缓冲区满*, *遇到换行字符*或*需要输入时*刷新缓冲区 (另一种刷新缓冲区的方法是**fflush()函数**)
# 四. 字符串和格式化输入/输出
## 1. 字符串简介
- **字符串**: 一个或多个字符的序列
	- printf ("这里面是字符串");
	- char a[ ] =我也是字符串; printf ("%s", a);
	- 也可以声明多个 char 字符, 再放入数组中 (**在末尾加一个\\0**, 不加也可以)
- ### char 类型数组和 null 字符
	- 字符串存储在连续的 char 类型的数组中
		- *空格也是一个字符, 字符串末尾还有\\0*
	- **空字符**\\0不是数字 0, 但是在 ASCII 编码中为 0 (**非打印字符**)
		- 数组的容量是**字符数+1**
		- \\0 是 char a=0; 而不是 char a='0'
- ### 使用字符串
	- printf ()和 scanf ()双引号内的文本是一个字符串,*编译器会在末尾加上空字符*
	- scanf ()只读取 Angela Plains 中的 Angela, 在遇到**第一个空白**(**空格, 制表符\\t,\\v 或换行符\\n**)时不再输入
		- scanf 只会读取一个单词而不是一句话
		- 其他输入函数: **fgets()**, 用于读取一般字符串 (包括空白)
	- 字符和字符串
		- 'x'是一个字符
		- "x"是一个字符串, 包含'x','\\0'
- ### strlen ()函数
	- sizeof 和 strlen
		- sizeof 占据的字节
		- <font color="#ffff00">strlen</font> 字符长度 (不包括'\\0')
	- ![[Pasted image 20230910230350.png]]
		- `char name[40]` sizeof 得到 40
		- strlen 是 11 (只有前 11 个用于存储)
## 2. 常数和 C 预处理器指令 
- 定义常量
	- 使用变量的缺点: 程序可能无意间改变其数值 
	- C 预处理器 `#define TAXRATE 0.015` 
		- **编译时替换**:编译时,程序中的 TAXRATE 都会替换成 0.015
		- **明示常量** `#define TAXRATE 0.015`
			- 在程序中不能⽤圆括号代替花括号
		- *常量一般使用大写; 无"="和";"* 
- ### const 限定符
	- 只读不写, 定义后不能改变
- ### 明示常量
	- limits. h 整数类型大小限制及实现他的明示变量
		- 例如: CHAR_BIT char 类型的位数
		- 表示效果
			- MAX 最大值 
			- MIN 最小值
			- `BIT` **位数**
		- 类型
			- `CHAR` char 类型
			- `SCHAR` signed char 类型
			- `UCHAR` unsigned char 类型
			- `INT` int 类型 
			- `UINT` unsigned int 类型
			- `LLONG` long long 类型
	- float. h
		- FLT_DIG 和 DBL_DIG，分别表示 float 类型和 double 类型的有效数字(**尾数**)位数
		- DBL 和 LDBL,分别表示 double 和 long double 类型
		- **明示变量**
			- `FLT_MANT_DIG` float 类型的尾数位数
			- `FLT_DIG` float 类型的最少有效数字位数（十进制）
			- `FLT_MIN(MAX)_10_EXP` 带全部有效数字的 float 类型的最小 (最大)负指数（以10为底）
			- `FLT_MIN (MAX)` **保留全部精度**的 float 类型最小 (最大)正数
			- `FLT_EPSILON` 1.00和比1.00⼤的最小 float 类型值之间的差值*1.192093e-07*
	- 例: printf("%d %e",FLT_DIG,FLT_EPSILON)
## 3. printf ()和 scanf ()
- 输出/输入函数，或简称为 I/O 函数
- 工作原理基本相同:**都使用格式字符串和参数列表**
- 不同:
	- printf()函数使⽤变量、常量和表达式
	- scanf()函数使⽤**指向变量的指针**
- ### printf ()函数
	- 转换说明汇总 ![[Pasted image 20230914165618.png]]
- ### 使用 printf ()
	- 格式:
		- printf( 格式字符串, 待打印项1, 待打印项2,...);
		- **格式字符串**包括**实际打印的字符**和**转换说明**
		- 可以这样![[Pasted image 20230912093423.png]]
	- 打印%要使用两个%
- ### printf ()的转换说明修饰符
	- *在%和转换字符之间插入修饰符可修饰基本的转换说明*![[Pasted image 20230911222143.png]]![[Pasted image 20230911181600.png]] ![[Pasted image 20230911181613.png]]
	- stddef. h 头文件把**size_t** 定义成系统使⽤ sizeof 返回的类型 (称为**底层类型**)
	- **ptrdiff_t** 类型和 **t** 修饰符来表示**系统使⽤的两个地址差值**的底层有符号整数类型![[Pasted image 20230911222011.png]]
- ### 转换说明的意义
	- **转换说明**
		- 把以二进制格式**存储在计算机中的值**转换成**⼀系列字符**(字符串)以便于显示
		- 例如:%x 转换说明把(01001100)转换成十六进制记数法4c
		- 转换说明是**翻译说明**，%d 的意思是把给定的字符<font color="#ffff00">翻译</font>成十进制整数文本并打印出来
	- **转换不匹配**
		- 转换说明的匹配
			- 打印 int 类型可使用%d,%x,%o
			- 打印 double 类型可使用%f,%e,%g
		- 系统使⽤二进制补码来表示有符号整数
		- 还可能出现[[计算机科学导论#^917111|截断]] 
			- 例如: 用一字节的 char 类型的转换说明%c 打印 2 字节的 int 类型, 只打印后一字节
		- 使用%e 打印 long int 变量错误原因
			- %e 让 printf()函数认为待打印的值是 double 类型 (double 8字节)当 printf()查看4字节的值时,还会查看相邻4字节;然后将8字节单元中的位组合解释成浮点数
	- *float 类型的值作为 printf() 参数时会被转换成 double 类型*
	- **参数传递**
		- 程序把传入的值放入被称为**栈**的内存区域
		- 会依次按照转换说明所需取的字节数读取
			- 例如:printf("%ld %ld", n1, n2)(long 类型 4 个字节, double 类型 8 个字节)
			- n1=3.0; 则第一个%ld 取 n1 的前 4 个字节; 第二个%ld 不是取得 n2 而是 n1 的后四个字节
		![[Pasted image 20230912092304.png]]
	- **printf ()的返回值**
		- printf()的返回值是**待显示**字符的个数
		- ⽤rv = printf(...);的形式把 printf()的返回值赋给 rv(rv 的值是 printf 输出的字符串中的**字符数**)
	- **打印较长的字符串**
		- 在字符串中,可使⽤\\n 换⾏,不可用 Enter 换⾏
		- 字符串断行方法 ![[Pasted image 20230912093533.png]]
		- *⽤反斜杠（\\）和 Enter 键组合来断⾏;在下⼀⾏开始 (不能缩进)继续输出*
- ### 使用 scanf ()
	- 简单规则
		- scanf()读取基本变量类型的值,在变量名前加&
		-  scanf()把字符串读入字符数组中,不⽤&
	- 在每个**输入项**之间输入至少⼀个换⾏符、空格或制表符 (可以输入多个, 都不会读取)*但是除了%c 读取字符会读取每一个空格*
		- 例如:scanf("%d%d", &n, &m)与 scanf("%d %d", &n, &m) 的⾏为相同
	- <font color="#ffff00">转换说明的不同</font>
		- printf ()对于 float 和 double 都使用%f (%e,%g)
		- scanf ()对于 float 使用%f (%e,%g); 而对 double 使用 l 修饰
	- **转换说明的修饰符**
		- 必须按照 `*`,数字, hh, ll, (h,l,L), j, z, t 的顺序 ![[Pasted image 20230912100247.png]]
	- **从 scanf ()角度看输出**
		- 使⽤带多个转换说明的 scanf(),在第1个出错处停止"**读取输入**"
		- *%s 会读取所有非空格字符, 遇到空白就停止*(使用最大字符宽度也不能让只有⼀个%s 的 scanf()读取多个单词; 但 printf 可以输出整句话, 包括空格)
	- **格式字符串中的普通字符**
		- 可以把普通字符放在格式字符串中; 例如 `scanf("%d,%d",&a,%b)` 则要输入 `2,3`
		- *空格在%c前,scanf ()会跳过空格,从第1个非空白字符开始读取*
			- scanf ("%c", &ch)从输⼊中的第1个字符 (可以是空白字符)开始读取
			- scanf (" %c", &ch)从第1个非空白字符开始读取
	- **scanf ()的返回值**:scanf()函数返回成功读取的项数 (**类似 printf 返回值**)
		- 例如: `status = scanf("%ld", &num);` scanf()成功读取⼀个整数,就把该数存⼊num 并返回1，然后将返回值赋给 status
		- 1.**返回-1**:当 scanf()检测到“文件结尾”时,会返回 EOF
			- （EOF 是 stdio.h 中定义的特殊值，通常⽤ `#define` 指令把 EOF 定义为-1)
		- 2.**返回 0**:没有读取任何项,且需要读取⼀个数字却输⼊⼀个非数值字符串
- ### printf ()和 scanf ()的 `*` 修饰符
	- printf ()中的 `*`
		- 不预先指定字段宽度,通过程序来指定,那么可以⽤ `*` 修饰符代替字段宽度
		- 例如: printf ("%2.3f", c); 可以写成 `printf ("%*.*f",a=2,b=3,c);`
	- scanf ()中的 `*`
		- 把 `*` 放在%和转换字符之间时,会使 scanf()跳过相应的输入项
		- 例如: `scanf("%*d %*d %d", &n);` 前两个被跳过 
- ### printf ()的用法提示
	- %9d 类似的用于数据的对齐
	- %.2f 可以更美观
	- **本地化设置**
		- 例如: 在荷兰语言环境下"." 是逗号","
		- C 标准有两个本地化设置: "C"和" "(空字符串)
# 五. 运算符, 表达式和语句
## 1. 基本运算符
- **pow() 函数**⽤于**指数**运算. 例如:pow(3.5, 2.2)返回3.5的2.2次幂
- =,+,-, `*`,/  都是二元运算符
- ### 赋值运算符:=
	- 左侧是变量名, 赋值从左往右
	- a=a+1:找出变量 a 的值,把该值加1,然后把新值赋值变量 a
	- **标识对象的方法**
		- 1. 使用变量名
		- 2. 指定数组的元素, 结构的成员
		- 3. 使用指针表达式
	- 术语:
		- **数据对象**: 
			- 概念:用于存储**值**的**数据存储区域**
			- 对象:实际的数据存储
			- 左值:用来表示或定位存储位置的标签
		- **左值**
			- 概念:标识**特定数据对象**的名称或表达式
			- 一些左值不能放在赋值的左侧: <font color="#ffff00">const 变量</font>
			- 赋值运算符的左侧是**可修改的左值**(又叫**对象定位值**)
		- **右值**(**表达式的值**)
			- 概念:能赋值给可修改左值的量,本身不是左值
			- 可以是常量, 变量或其他可求值的量
		- **运算对象**(项)
			- 运算对象是运算符操作的对象
			- 例如:赋值运算符左侧的"项"
	- *可进行多次连续赋值, 顺序**从右到左***
- ### 符号运算符
	- +-作加法减法运算符:**二元运算符**
	- +-作符号运算符时:**一元运算符**
- ### 除法运算符
	- **截断**:整数除法结果的丢弃小数部分 (不是四舍五入)
	- **趋零截断**: 当结果是负数时, 直接丢弃小数部分
- ### 运算符优先级
	- **表达式树**![[Pasted image 20230913204648.png]]
	- 优先级 (*!>算术>关系>&&>||>赋值*)
		- **初级运算符**( )、[ ]、->、.  高于**单目运算符**高于**算数运算符**(先乘除后加减)高于**关系运算符**高于**逻辑运算符**(不包括!) 高于**条件运算符**高于**赋值运算符**高于**逗号运算符**
		- 赋值,条件,单目运算符的平级间顺序**从右至左**, 其他都是**从左到右**![[Pasted image 20230913223039.png]]![[Pasted image 20230913223100.png]]![[Pasted image 20230913223121.png]]![[Pasted image 20230913223143.png]]
## 2. 其他运算符
- ### sizeof 运算符和 size_t 类型
	- sizeof (%zd)运算符以**字节**为单位返回运算对象的⼤小
		- 运算对象是类型,必须⽤圆括号括起来 (sizeof (int))
		- **sizeof** 返回**size_t** 类型的值
	- **typedef 机制**:允许程序员为现有类型创建别名
		- 例如: typedef double real;real 是 double 的别名
- ### 求模运算符:%
	- 整数运算, 取余. 例如:13%5 (读作“13 求模5”)得 3
	- *不同符号的数求模, 以第一个数的符号为准*
- ### 递增递减运算符:++  --
	- **++a ()先加 1 再取值**
	- **a++ ()先取值再加 1**
	- 一个良好的习惯
		- 如果不确定时, 可以分开使用
		- `b = ++i; // 如果使用i++，会得到不同的结果`
		- `++i; // 第1⾏ b = i; // 如果第1行使用i++,并不会影响b的值`
	- 递减运算符与递增运算符类似
- ### 注意事项
	- 不要一次用太多的递增递减运算符 
	- *⼀个变量出现在⼀个函数的多个参数中,不要对该变量使⽤递增或递减运算符*
		- 例如: `ans = num/2 + 5*(1 + num++);` 可能先计算 num/2, 也可能先计算 num++(这时会改变 num 的值, 使 num/2 的值改变)
	- ⼀个变量多次出现在⼀个表达式中，不要对该变量使⽤递增或递减运算符
		- 例如: n = 3; y = n++ + n++;
		- 原因: **副作用在序列点前结算**, 但未说明是运算后递增还是递增后运算
## 3. 表达式和语句 
- ### 表达式
	- 组成: **运算符**和**运算对象**(运算符操作的对象)
	- 表达式的值: 与赋值表达式**左侧**值相同
- ### 语句
	- `a=4` 是表达式; `a=4;` 是语句
	- **表达式语句**:以分号结尾的表达式
		- 声明不是表达式语句 (因为去掉分号不是表达式) 例如: `int a; `
	- **简单语句**
		- 最简单的语句是空语句 `;    //空语句`
		- (部分)语句可以**改变值**或**调⽤函数**; 那它是条完整的**指令**
			- 不是所有的指令都是语句;不是所有的语句都可以改变值或调⽤函数 (空语句)
			- 例如: x = 6 + ( y = 5 );y = 5是⼀条完整的指令,但它只是语句的⼀部分
	- **复合语句**(块)
		- ⽤{花括号}括起来的⼀条或多条简单语句
		- 应用: while, for循环, if 条件语句
	- **函数表达式语句**会引起**函数调⽤**
		- while 语句是⼀种**迭代**语句或**结构化**语句
- ### 副作用和序列点
	- **副作用**
		- 定义:对**数据对象**或文件的**修改** `states = 50;`
		- 解释: `states = 2+3;`
			- <font color="#ffff00">主作用</font>: 对表达式求值
			- 副作用:把变量 states 的值改为5
		- 应用:
			- 递增递减运算符就是使用其副作用
			- printf ()显示的信息也是副作用
	- **序列点**
		- 定义:程序执⾏的点 (**分号标记序列点**)
		- 作用:所有副作⽤都在进入下⼀步之前 (**在分号前**)发⽣
		- **完整表达式**
			- 定义: 完整表达式**不**是另⼀个更⼤表达式的**子表达式**
			- 联系: 完整表达式的结束是⼀个序列点
## 4. 类型转换
- **升级和降级**
	- **升级**:类型转换从较小的类型转换为较大类型
	- **降级**: 类型转换从较大的类型转换为较小类型
- 类型的**级别**: long double、double、float、 unsigned long long、long long、unsigned long、long、 unsigned int、int
	- 当 long 和 int 的⼤小相同时,unsigned int 比 long 的级别⾼
- **转换**(重要)
	- 1.类型转换出现在表达式时,char 和 short 都会被⾃动转换成 int
	- 2.在赋值表达式语句中,计算的最终结果会被转换成被赋值变量的类型
	- 3.当作为函数参数传递时，*char 和 short 被转换成 int，float 被转换成 double*
	- 4.涉及两种类型的运算,两个值会被分别转换成两种类型的更⾼级别
- 待赋值的值与目标类型不匹配
	- a=b; a 的类型为**目标类型**; a 是**被赋值变量**; b 是**待赋值的值**![[Pasted image 20230914123415.png]]
- **强制类型转换运算符**
	- **组成**:圆括号和它括起来的类型名 ` (int)`
	- 在某个量前面放置⽤(圆括号)括起来的类型名,该类型名就是希望转换成的目标类型
		- 例如: `mice = (int)1.6 + (int)1.7; ` mice=2
		- `mice = 1.6 + 1.7; ` mice=3 (先计算后截断)
	- 在函数调用时也可使用 `pound ((int)f);`
	- 使⽤**强制类型转换运算符**进⾏**显式转换**, 更直观
# 六. C 控制语句: 循环
- **伪代码**:⽤简单的句子表示程序思路的⽅法
# 1. while 语句
- **形式**: while (测试条件) {复合语句};
- 每次循环都被称为⼀次**迭代**
- 入口条件 (圆括号内)
- ### 终止 while 循环
	- 测试表达式的值有变化,表达式最终要为假
	- break 和 if 语句
- ### while 循环的形式
	- while (条件){复合语句};
	- 几种**易错**情况
		- while (条件); {复合语句};--循环体内为空语句
		- while (条件) 复合语句;--只会生效一条
	- 循环体使用空语句的情况
		- `while (scanf("%d", &num) == 1);` 跳过整数输⼊
		- 这个分号要独占⼀⾏, 提高代码可读性
## 2. 用关系运算符和表达式比较大小
- **关系运算符** "> < >= <= == !="
	- 不能用关系**运算符**比较字符**串**
	- 关系**表达式**比较字符时, 使用机器字符码 (ASCII)
	- **比较浮点数**时少使用"="
		- 原因:浮点数的舍入误差
- ### 真假
	- `while (goats)` 等价 `while (goats != 0)`
	- 关系表达式: 真>>求值为 1; 假>>求值为 0
	- **真** : 非 0 值 ;  **假**: 0
- ⼀个**无限失败**的循环 ( == 换成 = )
	- 当 scanf()把 q 作为整数读取时失败后,把 q 留下,下次循环时,scanf()从上次读取失败的地⽅（q）开始读取，还会失败
- ### _Bool 类型
	- **布尔变量** 
		- 定义:表示真假的变量
		- 只能存储1 (真)或0 (假)
		- *非 0 数值都会被设置为 1*
	- 使用示例: `bool = (scanf("%ld", &a) == 1); `
		- scanf 的返回值与 1 比较, 如果返回值 >=1 就为真, 则 bool=1
	- **stdbool.h 头文件** 
		- _ Bool 的别名 bool
		- true 和 false 定义为1和0的符号常量
		- 可以与 C++兼容:C++把 bool、true 和 false 定义为关键字
## 3. 不确定循环和计数循环
- **不确定循环**:测试表达式为假前,不知道要执⾏多少次循环
- **计数循环**:执⾏循环前知道要重复执⾏多少次
	- 步骤: 
		- 1.必须初始化计数器
		- 2.计数器与有限的值作比较
		- 3.每次循环时递增计数器
## 4. for 循环和 do while 循环
- ### for 循环 
- **形式** 
	- for (初始化; 判断条件; 改变量){复合语句}; 
	- 可以**省略**⼀个或多个表达式,但不能省略**分号**
		- 要保证不是**无限循环**
		- 表达式 2 省略后为**真** (1)
- **步骤**
	- ![[Pasted image 20230915154841.png]]
- 注意事项
	- **表达式 1** 在整个循环中只执行一次; 可以是其他表达式
		- 例如: `for (printf("abc\n"); num != 6;)`
	- **表达式 1,2** 中可以使用 char 字符, 也可以使用不同变量
		- 例如: `for (x = 1; y <= 75; y = (x++ * 5) + 50)`
	- **表达式 3** 中可以使用 a=a+10; a=a* 1.1...
- ### 逗号运算符和其他运算符
	- **其他运算符** += -= `*=` /= %=
		- a+=1; 等效于 a=a+1;
	- **逗号运算符**
		- 在表达式中使用逗号隔开, 可初始化多个变量
			- 例如: `for (a=1,b=2;a<=16;a++,b+=2)`
		- **逗号运算符**把两个表达式连接成⼀个表达式,并保证最左边的表达式最先求值
		- 逗号是**序列点**,左侧项的副作⽤在执⾏右侧项前发⽣
		- *整个式的值逗号表达是右侧项的值*
			- 例如:(b,c)== c
	- **注意**a=b,c; 和 a=(b,c);不同
		- a=b,c 等效于 a=b; c; 把 b 的值赋给 a, `c;` 什么也不做
		- a=(b,c); 把 c 的值赋给了 a
	- **逗号分隔符**
		- 下列语句中逗号为分隔符,不是逗号运算符
		- int a, b; printf ("%d %d\\n", a, b);
- ###  出口条件循环: do while 
	- **入口条件循环**(while 和 for)
		- 在循环的每次迭代前检查测试条件
		- **可能不执⾏**循环体中的内容
	- **出口条件循环**(do while)
		- 在循环的每次迭代后检查测试条件
		- 至少执⾏循环体中的内容**⼀次**
	- **形式**: do {复合语句} while (测试条件);
## 5. 嵌套循环
- **嵌套循环**:在⼀个循环内包含另⼀个循环, 常用于按行按列显示数据
- **嵌套变式**:内层循环开始打印的字符取决于外层循环的迭代次数 ![[Pasted image 20230915193138.png]]
## 6. 数组简介
- **数组**是按顺序存储的⼀系列类型相同的值
- 通过**下标**访问数组中单独的**项**或**元素**
	- 例如: `a[0] = 3;scanf("%f", &a[4]);`
- 数组的类型可以是任意数据类型
	- **形式**: int a[22];
![[Pasted image 20230915201050.png]]
- ### 在 for 循环中使用数组
	- 使用递增量 (i++) 将值存到数组的每个元素中 `for( i=0; i<10; i++ ) { scanf( "%d", &a[ i ] ) }`
- **模块化**:
	- 原则:把程序划分为⼀些独⽴的单元，每个单元执⾏⼀个任务,
	- 作用:可以提⾼程序的可读性
## 7. 计算幂的程序
- 计算幂的函数 ![[Pasted image 20230915204605.png]]
- 返回值也可以是表达式的值
	- 例如: return 2+a;
- ### 使用带返回值的函数
	- 声明函数、调⽤函数、定义函数、使⽤关键字 return，是定义和使⽤带返回值函数的**基本要素**
	- 为什么在定义中说明了 power()的返回类型为 double,还要单独声明这个函数?
		- 编译器在程序中首次遇到 power()时,需要知道 power()的返回类型
	- **前置声明**预先说明函数的返回类型
	- power()函数的定义在 main()的文件上面,就可以省略前置声明
# 七. C 控制语句: 分支和跳转
- if 语句被称为分支语句或选择语句
- if 语句由复合语句构成, 但整个 if 语句为⼀条语句
## 1. if else 语句
- **if 语句**
	- if 语句被称为分支语句或选择语句
	- if 语句由复合语句构成, 但整个 if 语句为⼀条语句
- **形式**: if (判断条件){复合语句} else {复合语句} 
- ### ctype. h 系列的字符函数
	- **isalpha()函数**的参数是⼀个字母,则返回⼀个非零值
		- 应用: if (<font color="#ffff00">isalpha(ch)</font>) 执行语句;
	- **字符映射**函数不会修改原始的参数,只会返回已修改的值
		- tolower(ch); 不改变 ch 的值
		- ch = tolower(ch);  改变 ch 的值
	- ctype.h 头文件中的**字符测试**函数 ![[Pasted image 20230917164719.png]]
		- **标准的**空白字符 (**空格,换⾏符**,换页符,回车符,垂直制表符,**水平制表符或其他本地化定义的字符**）--粗体为标准的
	- ctype.h 头文件中的**字符映射**函数 ![[Pasted image 20230917165503.png]]
- ### 多重选择 else if
	- **形式**: if (判断条件){复合语句}else if (...){...}
	- **else 与 if 配对**
		- **规则**:如果没有花括号,else 与离它最近的 if 匹配，除非最近的 if 被花括号括起来
		- 例如: else 与标记部分配对 ![[Pasted image 20230917214529.png]]
	- ![[Pasted image 20230917224132.png]]
## 2. 逻辑运算符 
- **&&与 ; ||或 ; !非**
	- `while ((status = scanf("%d", &code)) != 1 ||(code < 1 || code > 5))`
		- 在 scanf() 成功读入⼀个整数值后,才会检查 code 的值
- ### 备选拼写: iso 646. h 头文件
	- iso646.h 头文件中有可代替逻辑运算符的拼写 and 代替&&、or 代替||、not 代替!
- ### 求值顺序
	- **逻辑表达式**的求值顺序是从左往右
	- &&和||运算符都是**序列点**
	- 例如:
		- `while ((c = getchar()) != ' ' && c != '\n')`
		- `apples = (5 + 3) * (9 + 6); ` 无法确定先对 `5+3` 还是 `9+6` 求值
	- **高效性**
		- 例如: `if (number != 0 && 12/number == 2)` &&要求两个全为真,如果 number 的值是0，那么第 1个子表达式为假,且不再对关系表达式求值
		- `if (a<b||b++<a+b)` 如果 a< b 为真则跳过后一个子表达式
## 3. 条件运算符 ?:
- **三元运算符**
	- **形式**: <font color="#ffff00">表达式1 ? 表达式2 : 表达式3</font>
		- 如果表达式1为真,整个条件表达式的值与表达式2的值相同; 否则与表达式 3 的值相同
		- 例如: `x = (y < 0) ? -y : y;` 等效于 `if (y < 0) x = -y; else x = y;`
## 4. 辅助循环: continue 和 break 
- ### continue 语句
	- continue 只影响该层循环
	- *结束这轮循环, 开始下一轮循环*
	- **continue 的替换**
		- 原式: `if (score<0 || score>100){printf 语句; continue} 其他语句`
		- 例 1: `if (score<0 || score>100){printf 语句;}else {其他语句}`
		- 例 2: `if (score >= 0 && score <= 100) {其他语句}`
	- 使用 continue 的**好处**:减少主语句组中的⼀级**缩进**(替换掉了 else)
	- 用作**占位符** ![[Pasted image 20230918170115.png]]
	- 不同循环结束 continue 语句后的下一个行为
		- **while 和 do while 循环**:循环测试表达式求值
		- **for 循环**:更新表达式 (表达式 3)求值,然后对循环测试表达式 (表达式 2)求值
- ### break 语句
	- *结束该层循环, 进行下一步*
	- for 循环中的 break 语句会直接跳过更新表达式 (与 continue 中情况不同)
## 5. 多重选择: switch 和 break 
- ### switch 语句 
	- **switch 语句**:多选一 or 多选多
	- **标签**: case 'a'等
	- **形式**: ![[Pasted image 20230918172720.png]]
	- **执行过程**
		- 1.switch 后圆括号中的表达式求值
			- 圆括号和 case 标签中的值是**整数**(包括 char)
		- 2.程序扫描标签列表
		- 3.发现匹配的值跳转至那⼀⾏
			- **不**能⽤**变量**作为 case 标签
		- 4.没有匹配的标签 default
	- 注意: *continue 只能⽤于循环中*
		- C 语言的 case ⼀般都指定⼀个值,不能使⽤⼀个范围 
- ### 只读每行的首字母
	- 分析: 输入 ab 并按下 Enter 键时, ab 都进入循环并跳出 (相当于无事发生, 目的是跳过这些字符),直到读取到 Enter 键 (相当于'\\n')然后跳过该循环进入下一次读入, 则下一次读入下一行的首字母 ![[Pasted image 20230918203108.png]]
	- 为了处理第一次输入'\\n'的情况在开始时加上 `if(ch=='n')continue;`
- ### 多重标签
	- case 1: //case 2: //语句 (//表示换行)
- ### switch 和 if else
	- 根据**浮点**类型的变量或表达式来选择, 无法使用 switch
	- 判断条件是**范围** `if ( i < 10 && i  > 2 )`
## 6. go to 语句
- **组成**: goto 和标签名
	- 例如: `goto part2;` 和 `part2:printf("abc");
- ### 避免使用 goto
	- **原因**: 混乱不清, 容易犯错
	- 代替方法
		- 跳转到循环末尾,并开始下⼀轮迭代. C 使⽤continue 语句代替
		- 跳出循环,C 使⽤break 语句
	- **使用场景**
		- 出现问题时从**⼀组嵌套循环**中跳出 (break 语句只能跳出当前循环)
# 八. 字符输入输出的输入验证
## 1. 单字符 I/O: getchar putchar
- ### 介绍 getcher ()和 putchar ()
	- **getchar ()**
		- 不带任何参数, 它从输入队列中返回下⼀个字符 ch=getchar (); 等效 scanf ("%c",&ch);
		- **返回值**是输入字符对应的 ASCII 值
		- 一个 getchar 只能输入**一个字符** (执行一次只读取一个字符)
		- **换行符**'\\n'相当于 **Enter 键**
		- 与循环结合读取**字符串**
	- **putchar ()**
		- putchar (ch); 等效于 printf ("%c", ch);
	- getchar ()和 putchar ()不需要转换说明, 只处理**字符**
	- 通常是**预处理宏**, 不是真正的函数, 定义在 stdio. h 头文件
	- **注意**: 当输入 a 并按下 Enter 键时, 一个 getchar 只能读取一个字符, 换行符会缓存, 则下一个 getchar 会读取换行符 
## 2. 缓冲区
- **无缓冲(直接)输入**:输入字符后⽴即重复打印该字符
- **缓冲输⼊**:按下 Enter 键前不会重复打印刚输⼊的字符
	- 输入的字符被收集并存储在**缓冲区**(临时存储区)
- ![[Pasted image 20230918222453.png]]
- **完全缓冲 I/O 和⾏缓冲 I/O**
	- 完全缓冲输入:当缓冲区**被填满**时才刷新缓冲区 (内容被发送至目的地)
		- 应用: 文件输入
		- 大小: 常见的是 512 字节和 4096 字节
	- 行缓冲输入:出现**换⾏符**时刷新缓冲区
- **缓冲的选择**
	- C 标准规定输入是**缓冲**的
	- 一些编译器提供 **conio. h 函数**
		- **getche**(): 回显无缓冲输入
		- **getch**(): 无回显无缓冲输入
	- **回显与无回显输入**![[Pasted image 20230918225346.png]]
		- **回显**:显示正在执行的批处理命令及执行的结果
## 3. 结束键盘输入
- ### 文件, 流和键盘输入
	- **文件**
		- 含义:存储器中存储信息的区域
		- *某些程序需要访问指定的文件*
		- 引入文件, 流的**目的**: 用'EOF'代替'#'表示结束; 使 I/O 不限于键盘鼠标, 可以通过文件和流 I/O
	- **处理文件**
		- 较低层面上: C 可使⽤主机**操作系统的基本文件⼯具**直接处理文件
		- 较⾼层面上: C 可以通过**标准 I/O 包**来处理文件 (使⽤标准 I/O 包, 可避免不同的系统存储文件的⽅式不同的差异)
	- **底层 I/O**:直接调⽤操作系统的函数
	- <font color="#ffff00">C 程序处理的是流,不是直接处理文件</font>
	- **流**
		- 定义:⼀个实际输入或输出映射的**理想化数据流**
		- 用属性更**统⼀**的流来表示不同属性和不同种类的输入
		- 打开文件就是把<font color="#ffff00">流与文件相关联</font>; 文件的读写通过流完成
	- **stdin 流**表示键盘**输⼊**,**stdout 流**表示屏幕**输出** getchar()、putchar()、printf()和 scanf()函数都是标准 I/O 包的成员,处理这两个流
- ### 文件结尾
	- **检测方法**
		- 1.在文件末尾放⼀个特殊的字符标记**文件结尾**
			- 内嵌的 Ctrl+Z 字符
		- 2.存储文件大小的信息
	- scanf ()函数和 getchar()读取文件检测到文件结尾时将返回⼀个特殊的值，即EOF
		- EOF 定义在 stdio.h 文件中 `#define EOF (-1)` (一般是-1)
	- **注意:**
		- getchar()函数的返回类型是 int,如果把 getchar()的返回值赋给 char 类型的变量,可能会丢失数据
		- 在键盘输入表示 **EOF 字符**
			- **UNIX 和 Linux** 系统中,在⼀⾏开始处按下 **Ctrl+D** 会传输文件结尾信号
			- 微型计算机系统 (Windows)在⼀⾏开始按下 **Ctrl+Z**
			- 一些系统在任意位置按下 Ctrl+Z
## 4. 重定向和文件
- **默认情况**下,C 程序使⽤标准 I/O 包查找**标准输入**作为输入源(stdin 流), 将数据读入计算机
- 程序使用文件的方式
	- 1.显式使⽤**特定的函数**打开,关闭,读取,写入文件
	- 2.设计能与键盘和屏幕互动的程序,通过不同的渠道,**重定向**输入至文件和从文件输出 (即把 stdin 流重新赋给文件)
- ### UNIX, Linux 和 DOS 重定向
	- 重定向**改变了 I/O 的方式**
		- *默认是使用键盘打字通过**输入流**向该程序输入字符, 重定向后**输入流**连接文件, 文件中的字符通过输入流向程序输入字符*
		- **重定向输入**让程序使⽤文件而不是键盘;让程序输出至文件而不是屏幕
	- **处理文件**
		- 运行 c 编译后的文件 (可执行文件) `文件路径.exe`
		- 处理文本文件 (输入): `./echo_eof < words`
			- **文本文件**(.txt): 我们可以读懂的文字
		- 还有**机器语言指令**的文件不是文本文件
- ### 重定向符号
	- **重定向输入符号:<**
		- 系统 UNIX 和 DOS/Windows
		- **作用**:使 words 文件与 stdin 流相关联,把文件中的内容导入 (**输入**) 到echo_eof 程序
		- 重定向后, **文件**代替键盘屏幕成为 I/O 设备
		- **注意**: 
			- UNIX,Linux,Windows 命令提示 **<** 两侧的空格是可选的 (AmigaDOS 不能有空格)
	- **重定向输出符号:>**
		- `./echo_eof>mywords ` ⽤echo_eof 把键盘输入的内容发送 (**输出**) 到 mywords 文件中 
			- 屏幕显示的是你输入的字符, 而不是程序输出的字符
		- **作用**:创建⼀个名为 mywords 的新文件,然后把 echo_eof 的输出（输入字符的副本）**重定向**至该文件中
			- 如果存在同名文件, 会**清除**并存储
	- **组合重定向**
		- `./echo_eof < mywords > savewords` 制作 mywords 文件的副本,并命名为savewords
			- 命令与重定向运算符的**顺序无关**`./echo_eof > savewords < mywords`
			- 在⼀条命令中, 输入文件名和输出文件名不能相同
				- 原因:> mywords 在输入前已导致原 mywords 的长度被截断为0 (清除; 读取; 写入)
		- 注意: 
			- 1. *重定向运算符连接一个可执行程序和一个数据文件* (例如: 文本文档) 不可以连接两个可执行程序和数据文件
			- 2. 不能读取**多个文件**的输入, 不能把输出定向至多个文件
	- ****>>运算符**:把数据添加到现有文件的末尾
	- **| 运算符**:把⼀个文件的输出连接到另⼀个文件的输入
		- 管道运算符 (`|`) 将一个命令的输出传递给另一个命令的输入时，数据将直接流经管道，而不需要保存到文件中
- ### 注释
	- 重定向是⼀个**命令⾏概念**,要在命令⾏输入特殊的符号来发出指令
	- 不使⽤命令⾏环境,Windows 系统可以打开命令提示窗口,并在命令⾏运⾏可执⾏文件
## 5. 创建更友好的用户界面
- ### 使用缓冲输入
	- 现存问题:缓冲输入要求⽤户按下 Enter 键发送输 ⼊,这一动作也传送了换⾏符, 换行符也会被 getchar 读取
		- 例如:程序读取 n 作为⽤户否定了数字1，然后还读取了⼀个换⾏符作为⽤户否定了数字2 ![[Pasted image 20230920115525.png]]
		- 使每个答案都能有对应的回答
- ### 混合数值和字符输入
	- 假设程序要求⽤getchar()处理字符输入,⽤scanf()处理数值输入
		- 会导致第一次按下回车键后的换行符, 被第二次 while 循环中的 getchar 读取, 终止循环 ![[Pasted image 20230920124344.png]]
		- 在末尾去除多余的**空白**;scanf 后的 break 保证了输入不合理时能立即终止循环  ![[Pasted image 20230920124403.png]]
## 6. 输入验证
![[code.png]]
- 如果 get_long()函数处理这⼀⾏输入 `is 28 12.4 ` 第1个字符是非数字,那整⾏输入都会被丢弃,包括数字
- ch 的类型为 char ,会把数字当作字符
- **输入** (例如: 在键盘上打的字) 由**字符**组成, 但 scanf()可以把输入转换成整数值或浮点数值
	- 例如,输入字符"42", `scanf("%d", &x)`,那 `scanf()` 会**往%d (整数)方向**去解析这个字符,并将其转换为整数值42,然后将其存储在变量 `x` 中
- 使用转换说明 (如%d 或%f)限制了可接受输入的字符类型, 而 getchar()和使⽤%c 的 scanf()接受所有的字符
	- scanf ()使用%s 时不能读取**空白字符**, 但%c 可以
## 7. 菜单浏览
- 菜单是用户界面的一部分, 但菜单有两面性
	- 目标:⽤户遵循或**不遵循指令时**(实现难度较大)程序都能顺利运⾏
- ### 任务
	- 要获取⽤户的响应
	- 根据响应选择要执⾏的动作
	- 程序应该提供返回菜单的选项
- ### 混合字符和数值输入
![[code 1.png]]
# 九. 函数
## 1. 初识函数
- **函数**是完成特定任务的独⽴程序代码单元
	- *每个函数都能调用其它函数*
- **优点**
	- 1. 避免重复编写代码
	- 2. 让程序模块化, 便于后期修改
- ### 创建使用简单函数
	- 声明**函数原型**:告诉编译器函数 starbar()的签名
		- 形式: ![[Pasted image 20230922175128.png]]
		- **签名**: 函数的**返回值**类型;函数**接受的参数**类型
		- *函数的前置声明可以放在主调函数外也可以放在主调函数里*
	- **函数调⽤**:表明在此处执⾏函数 
		- 形式: `starbar();`
		- 执⾏到 starbar();语句时, 会找到函数的定义并执⾏其中的内容; 执⾏完后, 返回**主调函数**(main)继续执⾏下⼀⾏
	- 函数**定义**:明确地指定了函数要做什么 ![[Pasted image 20230922122629.png]]
		- 形式: `void starbar (void) {语句} ;`
	- `void starbar(void);` (用 void 表示无; 不要留空)
		- 第1个 void 是函数类型,void 类型表明函数没有返回值
		- 第2个 void (在圆括号中)表明该函数不带参数
		- 分号表明在**声明**函数,不是定义函数
	- 如果把函数放在⼀个单独的文件中，要把 # define 和 # include 指令也放入该文件
	- **局部变量**
		- 函数中的变量和函数外的变量为**同名不同变量**
- ### 带参数的函数
	- **参数类型**
		- 形式参数:**被调函数**中的变量
			- `void show_n_char(char ch, int num)` 中的 ch 和 num 为**形式参数**(形参), 形式参数也是局部变量
		- 实际参数:**主调函数**赋给**被调函数**的具体值
			- 提供了 ch 和 num 的值 `show_n_char(SPACE, 12);`
	- 文字居中: 文字前的空格数 ` spaces = ( WIDTH - strlen ( ADDRESS ) ) / 2 ; `
	- **驱动程序**:创建⼀个简单的 main(),⽤于检查 imin()是否正常⼯作;⽤于测试函数的程序
	- **返回值**
		- 主调函数 `lesser = imin(n,m);//将函数返回值赋值给lesser`
		- 被调函数中函数返回值可以是一个表达式 `return (n < m) ? n : m; `
		- 函数返回值的类型与函数声明的类型不匹配
			- 本质是 return 后面表达式或变量的值赋给了主调函数中的 lesser `return语句返回int类型的值1而不是1.23`
			- 与 `int a; a=3.14;//a为3` 是一个道理
		- `return;` 会导致终止函数,并把控制返回给主调函数
	- 没有返回值的函数应声明为 void 类型, 不声明会<font color="#ffff00">默认为 int</font>
## 2. ANSI C 函数原型
- 声明函数时**不声明函数类型**的缺点 `int imin();`
	- 可以执行但出错 ![[code 2.png]]
	- 主调函数把它的参数存储在被称为**栈**的临时存储区,被调函数从**栈**中读取这些参数
		- **主调函数**根据函数调⽤中的**实际参数**决定传递的类型, 而**被调函数**根据它的**形式参数**读取值
		- 例如: 1. 第一次读取 3 和**栈**中的其他数据; 2. 第二次按照 int 类型 (32 位)读取, 实际存入 double (64 位)
- 函数**声明**, 函数**定义**, 函数**调用**时的**变量名**相互独立
- 函数原型可以避免很多错误, 也可以不使用函数原型把函数定义放在主调函数前 (适用于小型程序)
## 3. 递归
- **递归**: 函数调用自己
	- 难点: 结束递归
	- 递归更简洁,但没有循环效率⾼
	- 缺点: 占用内存
- **过程**:fun1()调⽤fun2(),fun2()调⽤fun3();当 fun 3()结束时控制传回 fun 2(),当 fun2()结束时控制传回 fun1() ![[code1 1.png]]
	- 每级函数的变量**相互独立**(变量名相同, 但值不相同)
	- 递归调⽤前(后)的语句按被调函数(相反)的顺序执⾏
	- 递归函数必须包含能让递归调⽤**停止**的语句.如 if
- ### 递归和倒序运算
	- **尾递归**:递归调⽤置于函数的末尾 ( return 语句前)
		- **尾递归**是最**简单**的递归形式
	- **倒序运算**
		- 例如: 把十进制转化为二进制 (使用%和/) ![[code2.png]]
## 4. 编译多源代码文件的程序
- ### UNIX
	- `cc file1.c file2.c` 将编译两个文件并生成一个名为a.out 的可执行文件
	- `cc file1.c file2.o` 编译第1个文件，并与第2个文件的目标代码合并 
		- 目标文件 `file1.o和file2.o` 
	- **Linux**: 把 cc 换成 gcc
- ### Windows 和苹果的 IDE 编译器
	- IDE 中的编译器是面向**项目**的
		- 项目描述的是资源; 资源包括源代码文件
	- **单文件**:创建项目来运⾏单文件程序 (.exe)
	- **多文件**:使⽤相应的菜单命令,把**源代码文件**加入⼀个项目中
	- 要确保**所有的**<font color="#ffff00">源代码文件</font>都在**项目列表**中列出.许多 IDE 都不用在**项目列表**中列出<font color="#ffff00">头文件</font>（即扩展名为.h 的文件）
		- 项目列表 ![[Pasted image 20230923200409.png]]
		- 原因:项目只管理**使⽤的**源代码文件,源代码文件中的# include 指令管理**该文件中**使用的头文件
- ### 使用头文件
	- 把函数原型 (和已定义的字符常量)放在**头文件**中,就不⽤在每次使⽤函数文件时都写出函数原型
	- 主体文件.c, 函数定义文件.c, 常量和函数原型头文件.h
		- **主体文件**和**函数定义文件**中要包含 `#include <stido.h>和自定义的头文件#include "hotel.h"`
			- 双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）
		- 写上 `#include "hotel.h"` 相当于这个文件中包含了 hotel. h 中的语句和定义, 就*可以使用该头文件中定义的常量*且*不用再声明函数原型*
	- `scanf("%*s")` 是一个格式化输入函数 `scanf` 的调用，它的作用是**跳过并忽略**输入中的字符串
## 5. 查找地址:&运算符
- **指针**: 存储变量的地址
	- 指针的值是它所指向对象的地址,通常是该对象第⼀个字节的地址
- **函数返回值的数量**
	- *函数通常只能返回一个值*, 如果要"返回"多个值, 要使用**指针**
	- 函数中的变量是**局部变量** (函数定义中修改该值不会影响 main 中该变量的值 )
- **⼀元&运算符**
	- pooh 是变量名,那 &pooh 是变量的地址
	- PC 地址通常⽤十六进制形式表示
	- `printf("%d %p\n", pooh, &pooh);` 输出 `24 0B76`
- ### 间接运算符: `*`
	- `ptr = &pooh; `把 pooh 的地址赋给 ptr
		- 叫作: ptr“指向”pooh
		- ptr 是变量 (可修改的左值),&pooh 是**常量**(右值)
	- 使⽤**间接**运算符 (**解引⽤**运算符) `*` 找出存储在 pooh 中的值 `val = *ptr; // 找出ptr指向的值`
	- **&与 `*` 比较**
		- 地址运算符&后跟⼀个变量名时,&给出该变量的地址
		- 间接 (解引⽤)运算符 `*` 后跟⼀个指针名或地址时， `*` 给出存储在指针指向地址上的值
- ### 声明指针
	 - 声明指针必须要指定指针**所指向变量**的类型 ![[code3.png]]
	 - `int * pi;`  `pi` 是⼀个指针 , `* pi ` 是 int 类型
		 - `pi` 的类型: 指向 int 类型的指针
		 - 地址一般由无符号整数表示, 但不可以说指针是整数类型
	 - **格式**: `*` 和指针名间的空格可有可无,**声明**时⽤空格,**解引⽤变量**时省略空格
- ### 使用指针在函数间通信
	- ![[code4.png]] ![[Pasted image 20230923210307.png]]
		- 函数传递的是 x 的地址&x, 所以要定义指针变量 int* <font color="#ffff00">u</font> 接收 (并不是* x 接受) ;u 为 x 的地址
# 十. 数组和指针
## 1. 数组
- ### 初始化数组
	- 声明: int array[20]; 类型名称[数量]
		- const 只读不写 `const int days [MONTHS]`
	- `int powers[8] = {1,2,4,6,8,16,32,64};` (`[正整数表达式或变量或字面常量]`)
		- **变长数组**`int a=1;int arr[a];`
	- *数组未初始化, 空位为无用值; 部分初始化, 空位为 0; 初始化项目多于数组元素, 则错误*
		- 省略括号中的数字, 会自动匹配
		- 计算数组元素个数: `sizeof array/sizeof array[0]`
- ### 指定初始化器 (C 99)
	- 作用: 初始化指定元素
		- 传统语法: `int arr[6] = {0,0,0,0,0,212};`
		- 指定初始化器: `int arr[6] = {[5] = 212};`
	- 指定初始化器后有其他值, 会初始化指定元素后面的元素 `[6] = 4, 9, 10}` 则[7]=9;[8]=10
	- **数组元素赋值** ![[code7.png]]
- ### 数组边界
	- 使⽤越界的数组下标会导致程序改变其他变量的值 `arr[-1]替换数组后一个位置上的值` `arr[size]替换数组前一个位置上的值`
	- 使用循环遍历数组时, 使用 `i<size` `i<=size-1`
## 2.多维数组
- `int array[行][列]` (在计算机中是按顺序存储的)
	- `float rain[5][12];` 内含5个数组元素的数组，每个数组元素内含12个 float 类型的元素
- ### 初始化二维数组
	- `const int arr[2][2] = { {4,4}, {8,8} };`
	- 部分初始化后, 其余部分自动初始化为 0
	- **遍历二维数组**: 嵌套使用循环
## 3. 指针和数组
- 数组名是数组首元素的地址 `array==&array[0]`
- **指针加1**指的是增加**⼀个存储单元**
	- 加1后的地址是下一个元素的地址,不是下⼀个字节的地址
	- 将数组首元素地址赋值给指针, 指针变量加 1 相当于数组元素加 1
- 数组和指针的**关系** `arr + 2 == &arr[2] ` `*(arr + 2) == arr[2]`
	- `*(dates + 2) ` dates 第3个元素的值
	- `*dates + 2` dates 第1个元素的值加2
## 4. 函数, 数组和指针 
- 只有在函数原型或函数定义头中,才可⽤ `int ar[]` 代替 `int * ar`
	- `int ar[]` 只能⽤于声明形式参数, 定义数组时需要指定数组大小
- **声明数组形参**(函数原型可以省略参数名)
	- `int function(int *ar, int *, int ar[ ], int [ ] )`
- **函数定义中**(不能省略参数名)
	- `int function(int *ar, int ar[ ])`
- 一个数组传入函数, 函数将它当作指针, 因为数组的函数名是数组首元素的地址, 可以通过函数名加 1 解引用或者使用数组的下表来遍历
- ### 使用指针形参
	- 
